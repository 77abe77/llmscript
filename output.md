An extensive refactoring has been performed on the `ax-vanilla` framework to align with the capabilities of Google's Gemini 2.5 Pro model, enhance the expressiveness of program signatures, and introduce a dynamic scoping mechanism.

Here is a summary of the key changes:

1.  **Modernized Data and Signature Types (`dsp/types.ts`, `dsp/sig.ts`):**
    *   `AxFieldValue` has been updated to support a wider range of media types, including images, audio, and video, distinguishing between file URIs (`AxFileData`) and inline base64 data (`AxInlineData`).
    *   The `AxField` definition is now a powerful, type-safe discriminated union, allowing for nested JSON schemas (`schema`), rich enumeration types (`enumValueSet`), and special properties for referencing dynamic scope (`canReferenceScope`).
    *   The legacy string-based signature parser (`dsp/parser.ts`) has been removed in favor of a more robust, programmatic-first approach to defining signatures, as demonstrated in the updated `AxRAG` and `AxChainOfThought` programs.

2.  **Dynamic Scoping (`dsp/program.ts`):**
    *   `AxProgramWithSignature` now includes a `scope` for dynamically adding user-defined data at runtime. The new `updateScope()` method allows for adding, updating, or removing fields from this scope before program execution.

3.  **Advanced Prompt Engineering (`dsp/prompt.ts`):**
    *   `AxPromptTemplate` has been completely overhauled to generate sophisticated, XML-based prompts tailored for Gemini.
    *   It now constructs detailed system instructions that include XML definitions for input, output, and scope fields, along with guides on how to reference them using an XPath-like syntax (`<xpath>//path/to/field</xpath>`).
    *   It correctly assembles multimodal user inputs, interleaving text with media parts wrapped in XML tags, placing them in the appropriate slots within the Gemini `contents` array.

4.  **Gemini 2.5 Pro Integration (`ai/google-gemini/api.ts`):**
    *   The Gemini API adapter now intelligently configures `generationConfig` and `tools` to leverage native features like structured JSON output and function calling.
    *   It can seamlessly handle programs that define structured outputs, functions, or both, by treating the final desired output as a special `final_answer` tool when necessary.
    *   Payload creation (`createChatReq`) is now aligned with the new XML-based, multimodal prompt structure generated by `AxPromptTemplate`.

These changes collectively enable more complex, descriptive, and powerful interactions with the Gemini model, moving beyond simple text-in, text-out patterns to fully utilize its structured data and multimodal understanding capabilities.

Here are the modified files:

<file_contents>
File: /Users/abemillan/Developer/ax-vanilla/src/ax/ai/google-gemini/api.ts
```ts
import { getModelInfo } from '@ax-llm/ax/dsp/modelinfo.js'

import type { AxAPI } from '../../util/apicall.js'
import {
  AxBaseAI,
  axBaseAIDefaultConfig,
  axBaseAIDefaultCreativeConfig,
} from '../base.js'
import { GoogleVertexAuth } from '../google-vertex/auth.js'
import type {
  AxAIPromptConfig,
  AxAIServiceImpl,
  AxAIServiceOptions,
  AxChatResponse,
  AxChatResponseResult,
  AxEmbedResponse,
  AxInternalChatRequest,
  AxInternalEmbedRequest,
  AxModelConfig,
  AxModelInfo,
} from '../types.js'
import type {
  AxAIInputModelList,
  AxFunction,
  AxFunctionJSONSchema,
} from '../types.js'
import { type AxField, type AxSignature } from '../../dsp/sig.js'

import { axModelInfoGoogleGemini } from './info.js'
import {
  type AxAIGoogleGeminiBatchEmbedRequest,
  type AxAIGoogleGeminiBatchEmbedResponse,
  type AxAIGoogleGeminiChatRequest,
  type AxAIGoogleGeminiChatResponse,
  type AxAIGoogleGeminiChatResponseDelta,
  type AxAIGoogleGeminiConfig,
  AxAIGoogleGeminiEmbedModel,
  type AxAIGoogleGeminiGenerationConfig,
  AxAIGoogleGeminiModel,
  AxAIGoogleGeminiSafetyCategory,
  type AxAIGoogleGeminiSafetySettings,
  AxAIGoogleGeminiSafetyThreshold,
  type AxAIGoogleVertexBatchEmbedRequest,
  type AxAIGoogleVertexBatchEmbedResponse,
} from './types.js'

const safetySettings: AxAIGoogleGeminiSafetySettings = [
  {
    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHarassment,
    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,
  },
  {
    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHateSpeech,
    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,
  },
  {
    category: AxAIGoogleGeminiSafetyCategory.HarmCategorySexuallyExplicit,
    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,
  },
  {
    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryDangerousContent,
    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,
  },
]

/**
 * AxAIGoogleGemini: Default Model options for text generation
 */
export const axAIGoogleGeminiDefaultConfig = (): AxAIGoogleGeminiConfig =>
  structuredClone<AxAIGoogleGeminiConfig>({
    model: AxAIGoogleGeminiModel.Gemini15Flash,
    embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding004,
    safetySettings,
    ...axBaseAIDefaultConfig(),
  })

export const axAIGoogleGeminiDefaultCreativeConfig =
  (): AxAIGoogleGeminiConfig =>
    structuredClone<AxAIGoogleGeminiConfig>({
      model: AxAIGoogleGeminiModel.Gemini15Flash,
      embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding004,
      safetySettings,
      ...axBaseAIDefaultCreativeConfig(),
    })

export interface AxAIGoogleGeminiOptionsTools {
  codeExecution?: boolean
  googleSearchRetrieval?: {
    mode?: 'MODE_DYNAMIC'
    dynamicThreshold?: number
  }
  googleSearch?: boolean
  urlContext?: boolean
}

export interface AxAIGoogleGeminiArgs {
  name: 'google-gemini'
  apiKey?: string
  projectId?: string
  region?: string
  endpointId?: string
  config?: Readonly<Partial<AxAIGoogleGeminiConfig>>
  options?: Readonly<AxAIServiceOptions & AxAIGoogleGeminiOptionsTools>
  models?: AxAIInputModelList<AxAIGoogleGeminiModel, AxAIGoogleGeminiEmbedModel>
  modelInfo?: AxModelInfo[]
}

const toJSONSchema = (
  fields: readonly AxField[],
  sig?: Readonly<AxSignature>
): AxFunctionJSONSchema => {
  const properties: Record<string, unknown> = {}
  const required: Array<string> = []

  for (const f of fields) {
    if (f.isInternal) {
      continue
    }
    const type = f.type ? f.type : 'string'

    if (f.isArray) {
      properties[f.name] = {
        description: f.fieldDescription,
        type: 'array' as const,
        items:
          type === 'json' && 'schema' in f && f.schema
            ? toJSONSchema(f.schema, sig)
            : {
                type: type,
                description: f.fieldDescription,
              },
      }
    } else if (type === 'json' && 'schema' in f && f.schema) {
      properties[f.name] = toJSONSchema(f.schema, sig)
      properties[f.name].description = f.fieldDescription
    } else if (type === 'enum' && 'enumValueSet' in f) {
      if (f.enumValueSet.type === 'literal') {
        properties[f.name] = {
          description: f.fieldDescription,
          type: 'string',
          enum: f.enumValueSet.values,
        }
      }
      // Note: 'algebraic' enum types are not directly supported in JSON Schema enums
      // and would require more complex schema constructs like anyOf, which are omitted for simplicity.
    } else {
      properties[f.name] = {
        description: f.fieldDescription,
        type: type,
      }
    }

    if (!f.isOptional) {
      required.push(f.name)
    }
  }

  const schema = {
    type: 'object',
    properties: properties,
    required: required,
    description: sig?.getDescription(),
  }

  return schema as AxFunctionJSONSchema
}

class AxAIGoogleGeminiImpl
  implements
    AxAIServiceImpl<
      AxAIGoogleGeminiModel,
      AxAIGoogleGeminiEmbedModel,
      AxAIGoogleGeminiChatRequest,
      AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,
      AxAIGoogleGeminiChatResponse,
      AxAIGoogleGeminiChatResponseDelta,
      AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse
    >
{
  private tokensUsed: AxTokenUsage | undefined
  private signature?: AxSignature

  constructor(
    private config: AxAIGoogleGeminiConfig,
    private isVertex: boolean,
    private endpointId?: string,
    private apiKey?: string,
    private options?: AxAIGoogleGeminiArgs['options']
  ) {
    if (!this.isVertex && this.config.autoTruncate) {
      throw new Error('Auto truncate is not supported for GoogleGemini')
    }
  }

  getTokenUsage(): AxTokenUsage | undefined {
    return this.tokensUsed
  }

  getModelConfig(): AxModelConfig {
    const { config } = this
    return {
      maxTokens: config.maxTokens,
      temperature: config.temperature,
      topP: config.topP,
      topK: config.topK,
      presencePenalty: config.presencePenalty,
      frequencyPenalty: config.frequencyPenalty,
      stopSequences: config.stopSequences,
      endSequences: config.endSequences,
      stream: config.stream,
      n: config.n,
    } as AxModelConfig
  }

  createChatReq = (
    req: Readonly<AxInternalChatRequest<AxAIGoogleGeminiModel>>,
    config: Readonly<AxAIPromptConfig>
  ): [AxAPI, AxAIGoogleGeminiChatRequest] => {
    const model = req.model
    const stream = req.modelConfig?.stream ?? this.config.stream
    this.signature = req.signature

    if (!req.chatPrompt || req.chatPrompt.length === 0) {
      throw new Error('Chat prompt is empty')
    }

    let apiConfig
    if (this.endpointId) {
      apiConfig = {
        name: stream
          ? `/${this.endpointId}:streamGenerateContent?alt=sse`
          : `/${this.endpointId}:generateContent`,
      }
    } else {
      apiConfig = {
        name: stream
          ? `/models/${model}:streamGenerateContent?alt=sse`
          : `/models/${model}:generateContent`,
      }
    }

    if (!this.isVertex) {
      const pf = stream ? '&' : '?'
      apiConfig.name += `${pf}key=${this.apiKey}`
    }

    const systemPrompts = req.chatPrompt
      .filter((p) => p.role === 'system')
      .map((p) => (p.content as { type: 'text'; text: string }[]).at(0)?.text)

    const systemInstruction =
      systemPrompts.length > 0
        ? {
            role: 'user' as const,
            parts: [{ text: systemPrompts.join(' ') }],
          }
        : undefined

    const contents: AxAIGoogleGeminiChatRequest['contents'] = req.chatPrompt
      .filter((p) => p.role !== 'system')
      .map((msg, i) => {
        switch (msg.role) {
          case 'user': {
            const parts: Extract<
              AxAIGoogleGeminiChatRequest['contents'][0],
              { role: 'user' }
            >['parts'] = Array.isArray(msg.content)
              ? msg.content.map((c, i) => {
                  switch (c.type) {
                    case 'text':
                      return { text: c.text }
                    case 'image':
                      return {
                        inlineData: { mimeType: c.mimeType, data: c.image },
                      }
                    case 'file':
                      return {
                        fileData: { mimeType: c.mimeType, fileUri: c.fileUri },
                      }
                    default:
                      throw new Error(
                        `Chat prompt content type not supported (index: ${i})`
                      )
                  }
                })
              : [{ text: msg.content as string }]
            return {
              role: 'user' as const,
              parts,
            }
          }

          case 'assistant': {
            let parts: Extract<
              AxAIGoogleGeminiChatRequest['contents'][0],
              { role: 'model' }
            >['parts'] = []

            if (msg.functionCalls) {
              parts = msg.functionCalls.map((f) => {
                const args =
                  typeof f.function.params === 'string'
                    ? JSON.parse(f.function.params)
                    : f.function.params
                return {
                  functionCall: {
                    name: f.function.name,
                    args: args,
                  },
                }
              })

              if (!parts) {
                throw new Error('Function call is empty')
              }

              return {
                role: 'model' as const,
                parts,
              }
            }

            if (!msg.content) {
              throw new Error('Assistant content is empty')
            }

            parts = [{ text: msg.content as string }]
            return {
              role: 'model' as const,
              parts,
            }
          }

          case 'function': {
            if (!('functionId' in msg)) {
              throw new Error(`Chat prompt functionId is empty (index: ${i})`)
            }
            const parts: Extract<
              AxAIGoogleGeminiChatRequest['contents'][0],
              { role: 'function' }
            >['parts'] = [
              {
                functionResponse: {
                  name: msg.functionId,
                  response: { result: msg.result },
                },
              },
            ]

            return {
              role: 'function' as const,
              parts,
            }
          }

          default:
            throw new Error('Invalid role')
        }
      })

    let tools: AxAIGoogleGeminiChatRequest['tools'] = []
    const outputFields = req.signature?.getOutputFields() ?? []
    const hasOutputFields = outputFields.length > 0
    const functions = (req.functions ?? []).filter(
      (fn): fn is AxFunction => 'name' in fn
    )

    if (hasOutputFields && functions.length > 0) {
      const finalAnswerTool: AxFunction = {
        name: 'final_answer',
        description:
          'Call this function to return the final answer to the user.',
        parameters: toJSONSchema(outputFields, req.signature),
        func: () => {
          throw new Error('final_answer tool should not be called directly')
        },
      }
      tools.push({ function_declarations: [finalAnswerTool, ...functions] })
    } else if (functions.length > 0) {
      tools.push({ function_declarations: functions })
    }

    if (this.options?.codeExecution) {
      tools.push({ code_execution: {} })
    }

    if (this.options?.googleSearchRetrieval) {
      tools.push({
        google_search_retrieval: {
          dynamic_retrieval_config: this.options.googleSearchRetrieval,
        },
      })
    }

    if (this.options?.googleSearch) {
      tools.push({ google_search: {} })
    }

    if (this.options?.urlContext) {
      tools.push({ url_context: {} })
    }

    if (tools.length === 0) {
      tools = undefined
    }

    let toolConfig

    if (req.functionCall) {
      if (req.functionCall === 'none') {
        toolConfig = { function_calling_config: { mode: 'NONE' as const } }
      } else if (req.functionCall === 'auto') {
        toolConfig = { function_calling_config: { mode: 'AUTO' as const } }
      } else if (req.functionCall === 'required') {
        toolConfig = {
          function_calling_config: { mode: 'ANY' as const },
        }
      } else {
        const allowedFunctionNames = req.functionCall.function?.name
          ? {
              allowedFunctionNames: [req.functionCall.function.name],
            }
          : {}
        toolConfig = {
          function_calling_config: { mode: 'ANY' as const },
          ...allowedFunctionNames,
        }
      }
    } else if (tools && tools.length > 0) {
      toolConfig = { function_calling_config: { mode: 'AUTO' as const } }
    }

    const thinkingConfig: AxAIGoogleGeminiGenerationConfig['thinkingConfig'] =
      {}

    if (this.config.thinking?.includeThoughts) {
      thinkingConfig.includeThoughts = true
    }

    if (this.config.thinking?.thinkingTokenBudget) {
      thinkingConfig.thinkingBudget = this.config.thinking.thinkingTokenBudget
    }

    // Then, override based on prompt-specific config
    if (config.thinkingTokenBudget) {
      //The thinkingBudget must be an integer in the range 0 to 24576
      switch (config.thinkingTokenBudget) {
        case 'none':
          thinkingConfig.thinkingBudget = 0 // Explicitly set to 0
          break
        case 'minimal':
          thinkingConfig.thinkingBudget = 200
          break
        case 'low':
          thinkingConfig.thinkingBudget = 800
          break
        case 'medium':
          thinkingConfig.thinkingBudget = 5000
          break
        case 'high':
          thinkingConfig.thinkingBudget = 10000
          break
        case 'highest':
          thinkingConfig.thinkingBudget = 24500
          break
      }
    }

    if (config.showThoughts !== undefined) {
      thinkingConfig.includeThoughts = config.showThoughts
    }

    const generationConfig: AxAIGoogleGeminiGenerationConfig = {
      maxOutputTokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,
      temperature: req.modelConfig?.temperature ?? this.config.temperature,
      topP: req.modelConfig?.topP ?? this.config.topP,
      topK: req.modelConfig?.topK ?? this.config.topK,
      frequencyPenalty:
        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,
      candidateCount: 1,
      stopSequences:
        req.modelConfig?.stopSequences ?? this.config.stopSequences,

      ...(Object.keys(thinkingConfig).length > 0 ? { thinkingConfig } : {}),
    }

    // Handle structured output
    if (hasOutputFields && functions.length === 0) {
      generationConfig.responseMimeType = 'application/json'
      generationConfig.responseSchema = toJSONSchema(outputFields)
    } else {
      generationConfig.responseMimeType = 'text/plain'
    }

    const safetySettings = this.config.safetySettings

    const reqValue: AxAIGoogleGeminiChatRequest = {
      contents,
      tools,
      toolConfig,
      systemInstruction,
      generationConfig,
      safetySettings,
    }

    return [apiConfig, reqValue]
  }

  createEmbedReq = (
    req: Readonly<AxInternalEmbedRequest<AxAIGoogleGeminiEmbedModel>>
  ): [
    AxAPI,
    AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,
  ] => {
    const model = req.embedModel

    if (!model) {
      throw new Error('Embed model not set')
    }

    if (!req.texts || req.texts.length === 0) {
      throw new Error('Embed texts is empty')
    }

    let apiConfig
    let reqValue:
      | AxAIGoogleGeminiBatchEmbedRequest
      | AxAIGoogleVertexBatchEmbedRequest

    if (this.isVertex) {
      if (this.endpointId) {
        apiConfig = {
          name: `/${this.endpointId}:predict`,
        }
      } else {
        apiConfig = {
          name: `/models/${model}:predict`,
        }
      }

      reqValue = {
        instances: req.texts.map((text) => ({
          content: text,
          ...(this.config.embedType && { taskType: this.config.embedType }),
        })),
        parameters: {
          autoTruncate: this.config.autoTruncate,
          outputDimensionality: this.config.dimensions,
        },
      }
    } else {
      apiConfig = {
        name: `/models/${model}:batchEmbedContents?key=${this.apiKey}`,
      }

      reqValue = {
        requests: req.texts.map((text) => ({
          model: 'models/' + model,
          content: { parts: [{ text }] },
          outputDimensionality: this.config.dimensions,
          ...(this.config.embedType && { taskType: this.config.embedType }),
        })),
      }
    }

    return [apiConfig, reqValue]
  }

  createChatResp = (
    resp: Readonly<AxAIGoogleGeminiChatResponse>
  ): AxChatResponse => {
    const results: AxChatResponseResult[] = resp.candidates?.map(
      (candidate) => {
        const result: AxChatResponseResult = {}

        switch (candidate.finishReason) {
          case 'MAX_TOKENS':
            result.finishReason = 'length'
            break
          case 'STOP':
            result.finishReason = 'stop'
            break
          case 'SAFETY':
            throw new Error('Finish reason: SAFETY')
          case 'RECITATION':
            throw new Error('Finish reason: RECITATION')
          case 'MALFORMED_FUNCTION_CALL':
            throw new Error('Finish reason: MALFORMED_FUNCTION_CALL')
        }

        if (!candidate.content || !candidate.content.parts) {
          return result
        }

        for (const part of candidate.content.parts) {
          if ('text' in part) {
            // Check if this is a structured JSON response
            const outputFields = this.signature?.getOutputFields() ?? []
            if (
              outputFields.length > 0 &&
              resp.candidates[0]?.content.parts[0]?.text
            ) {
              try {
                // If the text is valid JSON, we assume it's the structured output
                const parsed = JSON.parse(
                  resp.candidates[0].content.parts[0].text
                )
                // Since it's a structured response, the whole text is the content.
                // It will be parsed later by `extractValues`.
                result.content = resp.candidates[0].content.parts[0].text
                break // exit the loop
              } catch (e) {
                // Not a JSON response, proceed as normal text
              }
            }

            if ('thought' in part && part.thought) {
              result.thought = part.text
            } else {
              result.content = part.text
            }
            continue
          }
          if ('functionCall' in part) {
            // Handle the `final_answer` tool case
            if (part.functionCall.name === 'final_answer') {
              result.content = JSON.stringify(part.functionCall.args)
            } else {
              result.functionCalls = [
                {
                  id: part.functionCall.name,
                  type: 'function',
                  function: {
                    name: part.functionCall.name,
                    params: part.functionCall.args,
                  },
                },
              ]
            }
          }
        }
        return result
      }
    )

    if (resp.usageMetadata) {
      this.tokensUsed = {
        totalTokens: resp.usageMetadata.totalTokenCount,
        promptTokens: resp.usageMetadata.promptTokenCount,
        completionTokens: resp.usageMetadata.candidatesTokenCount,
        thoughtsTokens: resp.usageMetadata.thoughtsTokenCount,
      }
    }
    return { results }
  }

  createChatStreamResp = (
    resp: Readonly<AxAIGoogleGeminiChatResponseDelta>
  ): AxChatResponse => {
    return this.createChatResp(resp)
  }

  createEmbedResp = (
    resp: Readonly<
      AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse
    >
  ): AxEmbedResponse => {
    let embeddings: number[][]
    if (this.isVertex) {
      embeddings = (resp as AxAIGoogleVertexBatchEmbedResponse).predictions.map(
        (prediction) => prediction.embeddings.values
      )
    } else {
      embeddings = (resp as AxAIGoogleGeminiBatchEmbedResponse).embeddings.map(
        (embedding) => embedding.values
      )
    }

    return {
      embeddings,
    }
  }
}

/**
 * AxAIGoogleGemini: AI Service
 */
export class AxAIGoogleGemini extends AxBaseAI<
  AxAIGoogleGeminiModel,
  AxAIGoogleGeminiEmbedModel,
  AxAIGoogleGeminiChatRequest,
  AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,
  AxAIGoogleGeminiChatResponse,
  AxAIGoogleGeminiChatResponseDelta,
  AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse
> {
  constructor({
    apiKey,
    projectId,
    region,
    endpointId,
    config,
    options,
    models,
    modelInfo,
  }: Readonly<Omit<AxAIGoogleGeminiArgs, 'name'>>) {
    const isVertex = projectId !== undefined && region !== undefined

    let apiURL
    let headers

    if (isVertex) {
      let path
      if (endpointId) {
        path = 'endpoints'
      } else {
        path = 'publishers/google'
      }

      apiURL = `https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/${path}`
      if (apiKey) {
        headers = async () => ({ Authorization: `Bearer ${apiKey}` })
      } else {
        const vertexAuth = new GoogleVertexAuth()
        headers = async () => ({
          Authorization: `Bearer ${await vertexAuth.getAccessToken()}`,
        })
      }
    } else {
      if (!apiKey) {
        throw new Error('GoogleGemini AI API key not set')
      }
      apiURL = 'https://generativelanguage.googleapis.com/v1beta'
      headers = async () => ({})
    }

    const _config = {
      ...axAIGoogleGeminiDefaultConfig(),
      ...config,
    }

    const aiImpl = new AxAIGoogleGeminiImpl(
      _config,
      isVertex,
      endpointId,
      apiKey,
      options
    )

    modelInfo = [...axModelInfoGoogleGemini, ...(modelInfo ?? [])]

    const supportFor = (model: AxAIGoogleGeminiModel) => {
      const mi = getModelInfo<
        AxAIGoogleGeminiModel,
        AxAIGoogleGeminiEmbedModel
      >({
        model,
        modelInfo,
        models,
      })
      return {
        functions: true,
        streaming: true,
        json: true,
        hasThinkingBudget: mi?.hasThinkingBudget ?? false,
        hasShowThoughts: mi?.hasShowThoughts ?? false,
        functionCot: false,
      }
    }

    super(aiImpl, {
      name: 'GoogleGeminiAI',
      apiURL,
      headers,
      modelInfo,
      defaults: {
        model: _config.model as AxAIGoogleGeminiModel,
        embedModel: _config.embedModel as AxAIGoogleGeminiEmbedModel,
      },
      options,
      supportFor,
      models,
    })
  }
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/ai/google-gemini/types.ts
```ts
import type { AxMediaMimeType } from '../../dsp/types.js'
import type { AxFunction, AxModelConfig } from '../types.js'

export enum AxAIGoogleGeminiModel {
  Gemini15Pro = 'gemini-1.5-pro-preview-0409',
  Gemini15Flash = 'gemini-1.5-flash-preview-0514',
}

export enum AxAIGoogleGeminiEmbedModel {
  TextEmbedding004 = 'text-embedding-004',
}

export enum AxAIGoogleGeminiSafetyCategory {
  HarmCategoryHarassment = 'HARM_CATEGORY_HARASSMENT',
  HarmCategoryHateSpeech = 'HARM_CATEGORY_HATE_SPEECH',
  HarmCategorySexuallyExplicit = 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
  HarmCategoryDangerousContent = 'HARM_CATEGORY_DANGEROUS_CONTENT',
}

export enum AxAIGoogleGeminiSafetyThreshold {
  BlockNone = 'BLOCK_NONE',
  BlockOnlyHigh = 'BLOCK_ONLY_HIGH',
  BlockMediumAndAbove = 'BLOCK_MEDIUM_AND_ABOVE',
  BlockLowAndAbove = 'BLOCK_LOW_AND_ABOVE',
  BlockDefault = 'HARM_BLOCK_THRESHOLD_UNSPECIFIED',
}

export enum AxAIGoogleGeminiEmbedTypes {
  SemanticSimilarity = 'SEMANTIC_SIMILARITY',
  Classification = 'CLASSIFICATION',
  Clustering = 'CLUSTERING',
  RetrievalDocument = 'RETRIEVAL_DOCUMENT',
  RetrievalQuery = 'RETRIEVAL_QUERY',
  QuestionAnswering = 'QUESTION_ANSWERING',
  FactVerification = 'FACT_VERIFICATION',
  CodeRetrievalQuery = 'CODE_RETRIEVAL_QUERY',
}

export type AxAIGoogleGeminiContentPart =
  | {
      text: string
      thought?: string
    }
  | {
      inlineData: {
        mimeType: AxMediaMimeType
        data: string
      }
    }
  | {
      fileData: {
        mimeType: AxMediaMimeType
        fileUri: string
      }
    }

export type AxAIGoogleGeminiContent =
  | {
      role: 'user'
      parts: AxAIGoogleGeminiContentPart[]
    }
  | {
      role: 'model'
      parts:
        | {
            text: string
          }[]
        | {
            functionCall: {
              name: string
              args: object
            }
          }[]
    }
  | {
      role: 'function'
      parts: {
        functionResponse: {
          name: string
          response: object
        }
      }[]
    }

export type AxAIGoogleGeminiToolFunctionDeclaration = AxFunction

export type AxAIGoogleGeminiToolGoogleSearchRetrieval = {
  dynamic_retrieval_config: {
    mode?: 'MODE_DYNAMIC'
    dynamic_threshold?: number
  }
}

export type AxAIGoogleGeminiTool = {
  function_declarations?: AxAIGoogleGeminiToolFunctionDeclaration[]
  code_execution?: object
  google_search_retrieval?: AxAIGoogleGeminiToolGoogleSearchRetrieval
  google_search?: object
  url_context?: object
}

export type AxAIGoogleGeminiToolConfig = {
  function_calling_config: {
    mode: 'ANY' | 'NONE' | 'AUTO'
    allowed_function_names?: string[]
  }
}

export type AxAIGoogleGeminiGenerationConfig = {
  temperature?: number
  topP?: number
  topK?: number
  frequencyPenalty?: number
  candidateCount?: number
  maxOutputTokens?: number
  stopSequences?: readonly string[]
  responseMimeType?: 'text/plain' | 'application/json'
  responseSchema?: object
  thinkingConfig?: {
    thinkingBudget?: number
    includeThoughts?: boolean
  }
}

export type AxAIGoogleGeminiSafetySettings = {
  category: AxAIGoogleGeminiSafetyCategory
  threshold: AxAIGoogleGeminiSafetyThreshold
}[]

export type AxAIGoogleGeminiChatRequest = {
  contents: AxAIGoogleGeminiContent[]
  tools?: AxAIGoogleGeminiTool[]
  toolConfig?: AxAIGoogleGeminiToolConfig
  systemInstruction?: AxAIGoogleGeminiContent
  generationConfig: AxAIGoogleGeminiGenerationConfig
  safetySettings?: AxAIGoogleGeminiSafetySettings
}

export type AxAIGoogleGeminiChatResponse = {
  candidates: {
    content: AxAIGoogleGeminiContent

    finishReason:
      | 'STOP'
      | 'MAX_TOKENS'
      | 'SAFETY'
      | 'RECITATION'
      | 'OTHER'
      | 'MALFORMED_FUNCTION_CALL'
    citationMetadata: {
      citations: {
        startIndex: number
        endIndex: number
        uri: string
        title: string
        license: string
        publicationDate: {
          year: number
          month: number
          day: number
        }
      }[]
    }
  }[]
  usageMetadata: {
    promptTokenCount: number
    candidatesTokenCount: number
    totalTokenCount: number
    thoughtsTokenCount: number
  }
}

export type AxAIGoogleGeminiChatResponseDelta = AxAIGoogleGeminiChatResponse

export type AxAIGoogleGeminiThinkingConfig = {
  thinkingTokenBudget?: number
  includeThoughts?: boolean
}

/**
 * AxAIGoogleGeminiConfig: Configuration options for Google Gemini API
 */
export type AxAIGoogleGeminiConfig = AxModelConfig & {
  model: AxAIGoogleGeminiModel
  embedModel?: AxAIGoogleGeminiEmbedModel
  safetySettings?: AxAIGoogleGeminiSafetySettings
  embedType?: AxAIGoogleGeminiEmbedTypes
  dimensions?: number
  autoTruncate?: boolean
  thinking?: AxAIGoogleGeminiThinkingConfig
  urlContext?: string
}

/**
 * AxAIGoogleGeminiEmbedRequest: Structure for making an embedding request to the Google Gemini API.
 */
export type AxAIGoogleGeminiBatchEmbedRequest = {
  requests: {
    model: string
    content: {
      parts: { text: string }[]
    }
  }[]
}

/**
 * AxAIGoogleGeminiEmbedResponse: Structure for handling responses from the Google Gemini API embedding requests.
 */
export type AxAIGoogleGeminiBatchEmbedResponse = {
  embeddings: {
    values: number[]
  }[]
}

/**
 * AxAIGoogleVertexBatchEmbedRequest: Structure for making an embedding request to the Google Vertex API.
 */
export type AxAIGoogleVertexBatchEmbedRequest = {
  instances: {
    content: string
    task_type?: AxAIGoogleGeminiEmbedTypes
  }[]
  parameters: {
    autoTruncate?: boolean
    outputDimensionality?: number
  }
}

/**
 * AxAIGoogleVertexBatchEmbedResponse: Structure for handling responses from the Google Vertex API embedding requests.
 */
export type AxAIGoogleVertexBatchEmbedResponse = {
  predictions: {
    embeddings: {
      values: number[]
    }
  }[]
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/extract.ts
```ts
/* eslint-disable @typescript-eslint/naming-convention */

import { parseLLMFriendlyDate, parseLLMFriendlyDateTime } from './datetime.js'
import type { AxField, AxSignature } from './sig.js'
import { matchesContent, parseMarkdownList } from './util.js'
import { ValidationError } from './validate.js'

export const extractValues = (
  sig: Readonly<AxSignature>,
  values: Record<string, unknown>,
  content: string
) => {
  const xstate = { extractedFields: [], streamedIndex: {}, s: -1 }
  streamingExtractValues(sig, values, xstate, content)
  streamingExtractFinalValue(sig, values, xstate, content)
}

export interface extractionState {
  prevFields?: { field: AxField; s: number; e: number }[]
  currField?: AxField
  currFieldIndex?: number
  extractedFields: AxField[]
  streamedIndex: Record<string, number>
  s: number
  inBlock?: boolean
}

// Helper function to check for missing required fields
const checkMissingRequiredFields = (
  xstate: Readonly<extractionState>,
  values: Record<string, unknown>,
  currentIndex: number
) => {
  const missingFields: AxField[] = []

  // Check all fields up to the current index
  for (let i = 0; i < currentIndex; i++) {
    const field = xstate.extractedFields[i]
    if (field && !field.isOptional && values[field.name] === undefined) {
      missingFields.push(field)
    }
  }

  if (missingFields.length > 0) {
    throw new ValidationError({
      message: `Required ${missingFields.length === 1 ? 'field' : 'fields'} not found`,
      fields: missingFields,
    })
  }
}

export const streamingExtractValues = (
  sig: Readonly<AxSignature>,
  values: Record<string, unknown>,
  // eslint-disable-next-line functional/prefer-immutable-types
  xstate: extractionState,
  content: string,
  streamingValidation: boolean = false
) => {
  const fields = sig.getOutputFields()

  for (const [index, field] of fields.entries()) {
    if (field.name in values) {
      continue
    }

    const isFirst = xstate.extractedFields.length === 0
    const prefix = (isFirst ? '' : '\n') + field.title + ':'
    let e = matchesContent(content, prefix, xstate.s)

    switch (e) {
      case -1:
        if (streamingValidation && values.length == 0 && !field.isOptional) {
          throw new ValidationError({
            message: 'Required field not found',
            fields: [field],
          })
        }
        continue // Field is not found, continue to the next field
      case -2:
        return true // Partial match at end, skip and gather more content
      case -3:
        return true // String is only whitespace, skip and gather more content
      case -4:
        xstate.inBlock = true
        return true // String is only backticks, skip and gather more content
    }
    // We found the next field!!!

    let prefixLen = prefix.length

    // Lets wrap up the last field which is still the current field
    if (xstate.currField) {
      const val = content.substring(xstate.s, e).trim()
      const parsedValue = validateAndParseFieldValue(xstate.currField, val)
      if (parsedValue !== undefined) {
        values[xstate.currField.name] = parsedValue
      }
      if (xstate.prevFields) {
        xstate.prevFields?.push({ field: xstate.currField, s: xstate.s, e })
      } else {
        xstate.prevFields = [{ field: xstate.currField, s: xstate.s, e }]
      }
    }

    checkMissingRequiredFields(xstate, values, index)

    // Lets update the state for the new current field

    xstate.s = e + prefixLen
    xstate.currField = field
    xstate.currFieldIndex = index

    if (!xstate.extractedFields.includes(field)) {
      xstate.extractedFields.push(field)
    }

    if (xstate.streamedIndex[field.name] === undefined) {
      xstate.streamedIndex[field.name] = 0
    }
  }
}

export const streamingExtractFinalValue = (
  sig: Readonly<AxSignature>,
  values: Record<string, unknown>,
  // eslint-disable-next-line functional/prefer-immutable-types
  xstate: extractionState,
  content: string
) => {
  if (xstate.currField) {
    let val = content.substring(xstate.s).trim()

    // Handle structured JSON output
    if (xstate.currField.type === 'json') {
      try {
        const parsed = JSON.parse(content)
        for (const key of Object.keys(parsed)) {
          if (key in values) {
            // value already extracted via streaming, do nothing
          } else {
            values[key] = parsed[key]
          }
        }
        return
      } catch (e) {
        // Not a JSON object, treat as a normal field
      }
    }

    const parsedValue = validateAndParseFieldValue(xstate.currField, val)
    if (parsedValue !== undefined) {
      values[xstate.currField.name] = parsedValue
    }
  }
  const sigFields = sig.getOutputFields()

  // Check all previous required fields before processing current field
  checkMissingRequiredFields(xstate, values, sigFields.length)
}

const convertValueToType = (
  field: Readonly<AxField>,
  val: string,
  required: boolean = false
) => {
  switch (field.type) {
    case 'code':
      return extractBlock(val)

    case 'string':
      return val

    case 'number': {
      const v = Number(val)
      if (Number.isNaN(v)) {
        if (field.isOptional && !required) {
          return
        }
        throw new Error('Invalid number')
      }
      return v
    }

    case 'boolean': {
      if (typeof val === 'boolean') {
        return val
      }
      const v = val.toLowerCase()
      if (v === 'true') {
        return true
      } else if (v === 'false') {
        return false
      } else {
        if (field.isOptional && !required) {
          return
        }
        throw new Error('Invalid boolean')
      }
    }
    case 'date':
      return parseLLMFriendlyDate(field, val, required)

    case 'datetime':
      return parseLLMFriendlyDateTime(field, val, required)

    case 'enum':
      const className = val
      if (
        'enumValueSet' in field &&
        field.enumValueSet.type === 'literal' &&
        !field.enumValueSet.values.includes(className)
      ) {
        if (field.isOptional) {
          return
        }
        throw new Error(
          `Invalid class '${val}', expected one of the following: ${field.enumValueSet.values.join(
            ', '
          )}`
        )
      }
      return className as string

    default:
      return val as string // Unknown type
  }
}

export function* yieldDelta<OUT>(
  content: string,
  field: Readonly<AxField>,
  s: number,
  e: number,
  // eslint-disable-next-line functional/prefer-immutable-types
  xstate: extractionState
) {
  const { name: fieldName, isInternal } = field
  const { isArray: fieldIsArray, type: fieldTypeName } = field

  if (
    isInternal ||
    fieldIsArray ||
    (fieldTypeName && fieldTypeName !== 'string' && fieldTypeName !== 'code')
  ) {
    return
  }

  const pos = xstate.streamedIndex[fieldName] ?? 0
  const isFirstChunk = pos === 0

  const d1 = content.substring(s + pos, e)
  if (d1.length === 0) {
    return
  }

  // Remove trailing whitespace, tabs, and newlines
  let d2 = d1.replace(/\s+$/, '')

  // If this field is a "code" type, remove trailing backticks
  if (xstate.currField?.type === 'code') {
    d2 = d2.replace(/\s*```\s*$/, '')
  }

  // Only trim start for the first chunk
  let d3 = isFirstChunk ? d2.trimStart() : d2

  if (xstate.currField?.type === 'code') {
    // Remove any leading triple-backtick fences (with optional language specifier)
    d3 = d3.replace(/^[ ]*```[a-zA-Z0-9]*\n\s*/, '')
  }

  if (d3.length > 0) {
    yield { [fieldName]: d3 } as Partial<OUT>
    xstate.streamedIndex[fieldName] = pos + d2.length
  }
}

// export function getStreamingDelta(
//   values: Record<string, unknown>,
//   // eslint-disable-next-line functional/prefer-immutable-types
//   xstate: extractionState
// ) {
//   return processStreamingDelta(values, xstate)
// }

export function* streamValues<OUT>(
  sig: Readonly<AxSignature>,
  content: string,
  values: Readonly<Record<string, OUT>>,
  // eslint-disable-next-line functional/prefer-immutable-types
  xstate: extractionState
) {
  for (const prevField of xstate.prevFields ?? []) {
    const { field, s, e } = prevField
    yield* yieldDelta<OUT>(content, field, s, e, xstate)
  }
  xstate.prevFields = undefined

  if (!xstate.currField || xstate.currField.isInternal) {
    return
  }

  yield* yieldDelta<OUT>(
    content,
    xstate.currField,
    xstate.s,
    content.length,
    xstate
  )

  const outputFields = sig.getOutputFields()

  for (const key of Object.keys(values)) {
    const field = outputFields.find((f) => f.name === key)
    if (!field || field.isInternal) {
      continue
    }

    const value = values[key]

    if (Array.isArray(value)) {
      const s = xstate.streamedIndex?.[key] ?? 0
      const v = value.slice(s)
      if (v && v.length > 0) {
        yield { [key]: v } as Partial<OUT>
        xstate.streamedIndex[key] = s + v.length
      }
      continue
    }

    if (!xstate.streamedIndex[key]) {
      yield { [key]: value } as Partial<OUT>
      xstate.streamedIndex[key] = 1
    }
  }
}

function validateAndParseFieldValue(
  field: Readonly<AxField>,
  fieldValue: string | undefined
): unknown {
  if (
    !fieldValue ||
    fieldValue === '' ||
    /^(null|undefined)\s*$/i.test(fieldValue)
  ) {
    if (field.isOptional) {
      return
    }
    throw new ValidationError({
      message: 'Required field is missing',
      fields: [field],
      value: fieldValue,
    })
  }

  let value: unknown | undefined

  if (field.type === 'json') {
    try {
      const text = extractBlock(fieldValue)
      value = JSON.parse(text)
      return value
    } catch (e) {
      throw new ValidationError({
        message: 'Invalid JSON: ' + (e as Error).message,
        fields: [field],
        value: fieldValue,
      })
    }
  }

  if (field.isArray) {
    try {
      try {
        value = JSON.parse(fieldValue)
      } catch {
        // If JSON parsing fails, try markdown parsing
        value = parseMarkdownList(fieldValue)
      }
      if (!Array.isArray(value)) {
        throw new Error('Expected an array')
      }
    } catch (e) {
      throw new ValidationError({
        message: 'Invalid Array: ' + (e as Error).message,
        fields: [field],
        value: fieldValue,
      })
    }
  }

  try {
    if (Array.isArray(value)) {
      for (const [index, item] of value.entries()) {
        if (item !== undefined) {
          const v = typeof item === 'string' ? item.trim() : item
          value[index] = convertValueToType(field, v, true)
        }
      }
    } else {
      value = convertValueToType(field, fieldValue)
    }
  } catch (e) {
    throw new ValidationError({
      message: (e as Error).message,
      fields: [field],
      value: fieldValue,
    })
  }

  if (typeof value === 'string' && value === '') {
    return undefined
  }

  return value
}

export const extractBlock = (input: string): string => {
  const markdownBlockPattern = /```([A-Za-z]*)\n([\s\S]*?)\n```/g
  const match = markdownBlockPattern.exec(input)
  if (!match) {
    return input
  }
  if (match.length === 3) {
    return match[2] as string
  }
  if (match.length === 2) {
    return match[1] as string
  }
  return input
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/fieldProcessor.ts
```ts
import type { AxAIMemory } from '../mem/types.js'

import type { extractionState } from './extract.js'
import type { AxField } from './sig.js'
import type { AxFieldValue, AxGenOut } from './types.js'

export type AxFieldProcessorProcess = (
  value: AxFieldValue,
  context?: Readonly<{
    values?: AxGenOut
    sessionId?: string
    done?: boolean
  }>
) => unknown | Promise<unknown>

export type AxStreamingFieldProcessorProcess = (
  value: string,
  context?: Readonly<{
    values?: AxGenOut
    sessionId?: string
    done?: boolean
  }>
) => unknown | Promise<unknown>
export interface AxFieldProcessor {
  field: Readonly<AxField>

  /**
   * Process the field value and return a new value (or undefined if no update is needed).
   * The returned value may be merged back into memory.
   * @param value - The current field value.
   * @param context - Additional context (e.g. memory and session id).
   */
  process: AxFieldProcessorProcess | AxStreamingFieldProcessorProcess
}

/**
 * For synchronous responses: iterates over registered field processors,
 * passing in the current values. If a processor returns a new value,
 * that value is merged into memory with a special role ('processor').
 */
export async function processFieldProcessors(
  fieldProcessors: AxFieldProcessor[],
  values: AxGenOut,
  mem: AxAIMemory,
  sessionId?: string
) {
  for (const processor of fieldProcessors) {
    if (values[processor.field.name] === undefined) {
      continue
    }

    const processFn = processor.process as AxFieldProcessorProcess
    const result = await processFn(values[processor.field.name], {
      sessionId,
      values,
      done: true,
    })
    addToMemory(processor.field, mem, result, sessionId)
  }
}

/**
 * For streaming responses: processes each streaming field processor
 * and yields delta updates if they return new values.
 */
export async function processStreamingFieldProcessors(
  fieldProcessors: AxFieldProcessor[],
  content: string,
  xstate: Readonly<extractionState>,
  mem: AxAIMemory,
  values: AxGenOut,
  sessionId: string | undefined,
  done: boolean = false
): Promise<void> {
  for (const processor of fieldProcessors) {
    if (xstate.currField?.name !== processor.field.name) {
      continue
    }

    let value = content.substring(xstate.s)

    if (xstate.currField?.type === 'code') {
      // remove markdown block
      value = value.replace(/^[ ]*```[a-zA-Z0-9]*\n\s*/, '')
      value = value.replace(/\s*```\s*$/, '')
    }
    const processFn = processor.process as AxStreamingFieldProcessorProcess
    const result = await processFn(value, {
      sessionId,
      values,
      done,
    })

    addToMemory(xstate.currField, mem, result, sessionId)
  }
}

const addToMemory = (
  field: Readonly<AxField>,
  mem: AxAIMemory,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  result: any | any[],
  sessionId?: string
) => {
  if (
    result === undefined ||
    (typeof result === 'string' &&
      (result === '' || /^(null|undefined)\s*$/i.test(result)))
  ) {
    return
  }

  let resultText = JSON.stringify(
    result,
    (key, value) => (typeof value === 'bigint' ? Number(value) : value),
    2
  )

  const text = getFieldProcessingMessage(field, resultText)
  mem.add({ role: 'user', content: [{ type: 'text', text }] }, sessionId)
  mem.addTag(`processor`, sessionId)
}

function getFieldProcessingMessage(
  field: Readonly<AxField>,
  resultText: string
) {
  const isCodeField = field.type === 'code'
  const fieldTitle = field.title

  if (isCodeField) {
    return `Code in the field "${fieldTitle}" was executed. The code execution produced the following output: ${resultText}`
  } else {
    return `The field "${fieldTitle}" was processed. The field contents were transformed into the following output: ${resultText}`
  }
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/generate.ts
```ts
import { ReadableStream } from 'node:stream/web'

import {
  context,
  type Context,
  type Span,
  SpanKind,
  trace,
  type Tracer,
} from '@opentelemetry/api'

import type {
  AxAIService,
  AxChatRequest,
  AxChatResponse,
  AxChatResponseResult,
  AxFunction,
  AxLoggerFunction,
  AxRateLimiterFunction,
} from '../ai/types.js'
import { mergeFunctionCalls } from '../ai/util.js'
import { AxMemory } from '../mem/memory.js'
import type { AxAIMemory } from '../mem/types.js'
import { AxAIServiceStreamTerminatedError } from '../util/apicall.js'

import {
  assertAssertions,
  assertStreamingAssertions,
  type AxAssertion,
  AxAssertionError,
  type AxStreamingAssertion,
} from './asserts.js'
import {
  type extractionState,
  extractValues,
  streamingExtractFinalValue,
  streamingExtractValues,
  streamValues,
} from './extract.js'
import {
  type AxFieldProcessor,
  processFieldProcessors,
  processStreamingFieldProcessors,
} from './fieldProcessor.js'
import {
  type AxChatResponseFunctionCall,
  type AxInputFunctionType,
  parseFunctionCalls,
  parseFunctions,
  processFunctions,
} from './functions.js'
import {
  type AxGenDeltaOut,
  type AxProgramExamples,
  type AxProgramForwardOptions,
  type AxProgramStreamingForwardOptions,
  AxProgramWithSignature,
  type AxSetExamplesOptions,
} from './program.js'
import { AxPromptTemplate } from './prompt.js'
import type { AxIField, AxSignature } from './sig.js'
import type {
  AxGenIn as AxGenInType,
  AxGenOut as AxGenOutType,
  AxMessage,
} from './types.js'
import { mergeDeltas } from './util.js'
import { handleValidationError, ValidationError } from './validate.js'

export interface AxGenOptions {
  maxRetries?: number
  maxSteps?: number
  mem?: AxAIMemory
  tracer?: Tracer
  rateLimiter?: AxRateLimiterFunction
  stream?: boolean
  description?: string
  thoughtFieldName?: string

  functions?: AxInputFunctionType
  functionCall?: AxChatRequest['functionCall']
  stopFunction?: string
  promptTemplate?: typeof AxPromptTemplate
  asserts?: AxAssertion[]
  streamingAsserts?: AxStreamingAssertion[]
  fastFail?: boolean
  excludeContentFromTrace?: boolean
  traceLabel?: string
  logger?: AxLoggerFunction
}

export type AxGenerateResult<OUT extends AxGenOutType> = OUT & {
  thought?: string
}

export interface AxResponseHandlerArgs<T> {
  ai: Readonly<AxAIService>
  model?: string
  res: T
  mem: AxAIMemory
  sessionId?: string
  traceId?: string
  functions?: Readonly<AxFunction[]>
  fastFail?: boolean
  span?: Span
}

export interface AxStreamingEvent<T> {
  event: 'delta' | 'done' | 'error'
  data: {
    contentDelta?: string
    partialValues?: Partial<T>
    error?: string
    functions?: AxChatResponseFunctionCall[]
  }
}

export class AxGen<
  IN extends AxGenInType | ReadonlyArray<AxMessage> =
    | AxGenInType
    | ReadonlyArray<AxMessage>,
  OUT extends AxGenerateResult<AxGenOutType> = AxGenerateResult<AxGenOutType>,
> extends AxProgramWithSignature<IN, OUT> {
  private promptTemplate: AxPromptTemplate
  private asserts: AxAssertion[]
  private streamingAsserts: AxStreamingAssertion[]
  private options?: Omit<AxGenOptions, 'functions'>
  private functions?: AxFunction[]
  private functionsExecuted: Set<string> = new Set<string>()
  private fieldProcessors: AxFieldProcessor[] = []
  private streamingFieldProcessors: AxFieldProcessor[] = []
  private values: AxGenOutType = {}
  private excludeContentFromTrace: boolean = false
  private thoughtFieldName: string
  private logger?: AxLoggerFunction

  constructor(
    signature: Readonly<AxSignature>,
    options?: Readonly<AxGenOptions>
  ) {
    super(signature, { description: options?.description })

    this.options = options
    this.logger = options?.logger
    this.thoughtFieldName = options?.thoughtFieldName ?? 'thought'
    const promptTemplateOptions = {
      functions: options?.functions,
      thoughtFieldName: this.thoughtFieldName,
    }
    this.promptTemplate = new (options?.promptTemplate ?? AxPromptTemplate)(
      this.signature,
      promptTemplateOptions
    )
    this.asserts = this.options?.asserts ?? []
    this.streamingAsserts = this.options?.streamingAsserts ?? []
    this.excludeContentFromTrace = options?.excludeContentFromTrace ?? false
    this.usage = []

    if (options?.functions) {
      this.functions = parseFunctions(options.functions)
    }
  }

  public addAssert = (fn: AxAssertion['fn'], message?: string) => {
    this.asserts.push({ fn, message })
  }

  public addStreamingAssert = (
    fieldName: string,
    fn: AxStreamingAssertion['fn'],
    message?: string
  ) => {
    this.streamingAsserts.push({ fieldName, fn, message })
  }

  private addFieldProcessorInternal = (
    fieldName: string,
    fn: AxFieldProcessor['process'],
    streaming = false
  ) => {
    const field = this.signature
      .getOutputFields()
      .find((f) => f.name === fieldName)

    if (!field) {
      throw new Error(`addFieldProcessor: field ${fieldName} not found`)
    }

    if (streaming) {
      const ft = field.type
      const isText = !ft || ft === 'string' || ft === 'code'

      if (!isText) {
        throw new Error(
          `addFieldProcessor: field ${fieldName} is must be a text field`
        )
      }
      this.streamingFieldProcessors.push({ field, process: fn })
    } else {
      this.fieldProcessors.push({ field, process: fn })
    }
  }

  public addStreamingFieldProcessor = (
    fieldName: string,
    fn: AxFieldProcessor['process']
  ) => {
    this.addFieldProcessorInternal(fieldName, fn, true)
  }

  public addFieldProcessor = (
    fieldName: string,
    fn: AxFieldProcessor['process']
  ) => {
    this.addFieldProcessorInternal(fieldName, fn, false)
  }

  private async forwardSendRequest({
    ai,
    mem,
    options,
    traceContext,
    firstStep,
  }: Readonly<{
    ai: Readonly<AxAIService>
    mem: AxAIMemory
    options?: Omit<AxProgramForwardOptions, 'ai' | 'mem'>
    traceContext?: Context
    firstStep: boolean
  }>) {
    const {
      sessionId,
      traceId,
      modelConfig,
      model,
      rateLimiter,
      stream,
      functions: _functions,
      functionCall: _functionCall,
      thinkingTokenBudget,
      showThoughts,
    } = options ?? {}

    const chatPrompt = mem?.history(sessionId) ?? []

    if (chatPrompt.length === 0) {
      throw new Error('No chat prompt found')
    }

    // biome-ignore lint/complexity/useFlatMap: you cannot use flatMap here
    const functions = _functions
      ?.map((f) => ('toFunction' in f ? f.toFunction() : f))
      ?.flat()

    let functionCall = _functionCall ?? this.options?.functionCall

    if (
      !firstStep &&
      (functionCall === 'required' || typeof functionCall === 'function')
    ) {
      functionCall = undefined
    }

    const res = await ai.chat(
      {
        chatPrompt,
        functions,
        functionCall,
        modelConfig,
        model,
        signature: this.signature,
      },
      {
        sessionId,
        traceId,
        rateLimiter,
        stream,
        debug: false,
        thinkingTokenBudget,
        showThoughts,
        traceContext,
        abortSignal: options?.abortSignal,
      }
    )

    return res
  }

  private async *forwardCore({
    ai,
    mem,
    options,
    firstStep,
    span,
    traceContext,
  }: Readonly<{
    ai: Readonly<AxAIService>
    mem: AxAIMemory
    options: Omit<AxProgramForwardOptions, 'ai' | 'mem'>
    firstStep: boolean
    span?: Span
    traceContext?: Context
  }>) {
    const { sessionId, traceId, functions: _functions } = options ?? {}
    const fastFail = options?.fastFail ?? this.options?.fastFail

    const model = options.model

    // biome-ignore lint/complexity/useFlatMap: you cannot use flatMap here
    const functions = _functions
      ?.map((f) => ('toFunction' in f ? f.toFunction() : f))
      ?.flat()

    const res = await this.forwardSendRequest({
      ai,
      mem,
      options,
      traceContext,
      firstStep,
    })

    if (res instanceof ReadableStream) {
      yield* this.processStreamingResponse({
        ai,
        model,
        res,
        mem,
        traceId,
        sessionId,
        functions,
        fastFail,
        span,
      })
    } else {
      yield await this.processResponse({
        ai,
        model,
        res,
        mem,
        traceId,
        sessionId,
        functions,
        span,
      })
    }
  }

  private async *processStreamingResponse({
    ai,
    model,
    res,
    mem,
    sessionId,
    traceId,
    functions,
    fastFail,
    span,
  }: Readonly<AxResponseHandlerArgs<ReadableStream<AxChatResponse>>>) {
    const streamingValidation =
      fastFail ?? ai.getFeatures(model).functionCot !== true
    const functionCalls: NonNullable<AxChatResponseResult['functionCalls']> = []
    this.values = {}
    const xstate: extractionState = {
      extractedFields: [],
      streamedIndex: {},
      s: -1,
    }

    let content = ''

    for await (const v of res) {
      const result = v.results[0]
      if (!result) {
        continue
      }

      if (v.modelUsage) {
        this.usage.push(v.modelUsage)
      }

      if (result.functionCalls && result.functionCalls.length > 0) {
        mergeFunctionCalls(functionCalls, result.functionCalls)
        mem.updateResult(
          {
            name: result.name,
            content,
            functionCalls,
            delta: result.functionCalls?.[0]?.function?.params as string,
          },
          sessionId
        )
      } else if (result.content && result.content.length > 0) {
        if (result.thought && result.thought.length > 0) {
          yield {
            [this.thoughtFieldName]: result.thought,
          } as AxGenDeltaOut<OUT>['delta']
        }

        content += result.content

        mem.updateResult(
          { name: result.name, content, delta: result.content },
          sessionId
        )

        const skip = streamingExtractValues(
          this.signature,
          this.values,
          xstate,
          content,
          streamingValidation
        )

        if (skip) {
          continue
        }

        if (this.streamingAsserts.length !== 0) {
          await assertStreamingAssertions(
            this.streamingAsserts,
            xstate,
            content
          )
        }

        if (this.streamingFieldProcessors.length !== 0) {
          await processStreamingFieldProcessors(
            this.streamingFieldProcessors,
            content,
            xstate,
            mem,
            this.values,
            sessionId
          )
        }

        yield* streamValues<OUT>(
          this.signature,
          content,
          this.values as Record<string, OUT>,
          xstate
        )

        await assertAssertions(this.asserts, this.values)
      } else if (result.thought && result.thought.length > 0) {
        this.values[this.thoughtFieldName] =
          (this.values[this.thoughtFieldName] ?? '') + result.thought
        yield {
          [this.thoughtFieldName]: result.thought,
        } as AxGenDeltaOut<OUT>['delta']
      }

      if (result.finishReason === 'length') {
        throw new Error(
          `Max tokens reached before completion\nContent: ${content}`
        )
      }
    }

    const funcs = parseFunctionCalls(ai, functionCalls, this.values, model)
    if (funcs) {
      if (!functions) {
        throw new Error('Functions are not defined')
      }
      const fx = await processFunctions(
        ai,
        functions,
        funcs,
        mem,
        sessionId,
        traceId,
        span,
        this.excludeContentFromTrace
      )
      this.functionsExecuted = new Set([...this.functionsExecuted, ...fx])
    } else {
      streamingExtractFinalValue(this.signature, this.values, xstate, content)

      await assertStreamingAssertions(
        this.streamingAsserts,
        xstate,
        content,
        true
      )
      await assertAssertions(this.asserts, this.values)

      if (this.fieldProcessors.length) {
        await processFieldProcessors(
          this.fieldProcessors,
          this.values,
          mem,
          sessionId
        )
      }

      if (this.streamingFieldProcessors.length !== 0) {
        await processStreamingFieldProcessors(
          this.streamingFieldProcessors,
          content,
          xstate,
          mem,
          this.values,
          sessionId,
          true
        )
      }

      yield* streamValues<OUT>(
        this.signature,
        content,
        this.values as Record<string, OUT>,
        xstate
      )
    }

    if (ai.getOptions().debug) {
      const logger = ai.getLogger()
      logger('', { tags: ['responseEnd'] })
    }
  }

  private async processResponse({
    ai,
    res,
    mem,
    sessionId,
    traceId,
    functions,
    span,
  }: Readonly<AxResponseHandlerArgs<AxChatResponse>>): Promise<OUT> {
    this.values = {}

    let results = res.results ?? []

    if (results.length > 1) {
      results = results.filter((r) => r.functionCalls)
    }

    for (const result of results) {
      if (res.modelUsage) {
        this.usage.push(res.modelUsage)
      }

      mem.addResult(result, sessionId)

      if (result.functionCalls?.length) {
        const funcs = parseFunctionCalls(ai, result.functionCalls, this.values)
        if (funcs) {
          if (!functions) {
            throw new Error('Functions are not defined')
          }
          const fx = await processFunctions(
            ai,
            functions,
            funcs,
            mem,
            sessionId,
            traceId,
            span,
            this.excludeContentFromTrace
          )
          this.functionsExecuted = new Set([...this.functionsExecuted, ...fx])
        }
      } else if (result.content) {
        if (result.thought && result.thought.length > 0) {
          this.values[this.thoughtFieldName] = result.thought
        }

        try {
          const parsed = JSON.parse(result.content)
          this.values = { ...this.values, ...parsed }
        } catch (e) {
          extractValues(this.signature, this.values, result.content)
        }
        await assertAssertions(this.asserts, this.values)

        if (this.fieldProcessors.length) {
          await processFieldProcessors(
            this.fieldProcessors,
            this.values,
            mem,
            sessionId
          )
        }
      }

      if (result.finishReason === 'length') {
        throw new Error(
          `Max tokens reached before completion\nContent: ${result.content}`
        )
      }
    }

    // Strip out values whose signature fields have isInternal: true
    for (const field of this.signature.getOutputFields()) {
      if (field.isInternal) {
        delete this.values[field.name]
      }
    }

    return { ...this.values } as unknown as OUT
  }

  private async *_forward2(
    ai: Readonly<AxAIService>,
    values: IN,
    options: Readonly<AxProgramForwardOptions>,
    span?: Span,
    traceContext?: Context
  ) {
    const stopFunction = (
      options?.stopFunction ?? this.options?.stopFunction
    )?.toLowerCase()

    const maxRetries = options.maxRetries ?? this.options?.maxRetries ?? 10
    const maxSteps = options.maxSteps ?? this.options?.maxSteps ?? 10
    const debug = options.debug ?? ai.getOptions().debug
    const debugHideSystemPrompt = options.debugHideSystemPrompt
    const memOptions = { debug, debugHideSystemPrompt }

    const mem =
      options.mem ?? this.options?.mem ?? new AxMemory(10000, memOptions)

    let err: ValidationError | AxAssertionError | undefined

    if (options?.functions && options.functions.length > 0) {
      const promptTemplateClass =
        this.options?.promptTemplate ?? AxPromptTemplate
      const currentPromptTemplateOptions = {
        functions: options.functions,
        thoughtFieldName: this.thoughtFieldName,
      }
      this.promptTemplate = new promptTemplateClass(
        this.signature,
        currentPromptTemplateOptions
      )
    }

    // New logic:
    let prompt
    if (Array.isArray(values)) {
      // We'll need to decide how to get the 'individual' IN for demos/examples if needed by render.
      // For now, assume render will handle the array directly.
      // The generic type for render might need to be T (from render<T extends ...>)
      // and T will be inferred as ReadonlyArray<AxMessage>
      prompt = this.promptTemplate.render(values, {
        examples: this.examples,
        demos: this.demos,
        scope: this.getScope(),
      })
    } else {
      // Ensure `values` here is correctly inferred as AxGenInType
      prompt = this.promptTemplate.render(values as AxGenInType, {
        // Cast if necessary
        examples: this.examples,
        demos: this.demos,
        scope: this.getScope(),
      })
    }

    mem.add(prompt, options?.sessionId)

    multiStepLoop: for (let n = 0; n < maxSteps; n++) {
      const firstStep = n === 0
      for (let errCount = 0; errCount < maxRetries; errCount++) {
        try {
          const generator = this.forwardCore({
            options,
            ai,
            mem,
            firstStep,
            span,
            traceContext,
          })
          for await (const delta of generator) {
            if (delta !== undefined) {
              yield { version: errCount, delta }
            }
          }

          const lastMemItem = mem.getLast(options?.sessionId)
          const shouldContinue = this.shouldContinueSteps(
            lastMemItem,
            stopFunction
          )

          if (shouldContinue) {
            continue multiStepLoop
          }

          if (debug) {
            const logger = options.logger ?? this.logger ?? ai.getLogger()
            logger('', { tags: ['responseEnd'] })
          }

          return
        } catch (e) {
          let errorFields: AxIField[] | undefined

          span?.recordException(e as Error)

          if (e instanceof ValidationError) {
            errorFields = e.getFixingInstructions()
            err = e

            // Add telemetry event for validation error
            if (span) {
              span.addEvent('validation.error', {
                message: e.toString(),
                fixing_instructions:
                  errorFields?.map((f) => f.title).join(', ') ?? '',
              })
            }
          } else if (e instanceof AxAssertionError) {
            const e1 = e as AxAssertionError
            errorFields = e1.getFixingInstructions()
            err = e

            // Add telemetry event for assertion error
            if (span) {
              span.addEvent('assertion.error', {
                message: e1.toString(),
                fixing_instructions:
                  errorFields?.map((f) => f.title).join(', ') ?? '',
              })
            }
          } else if (e instanceof AxAIServiceStreamTerminatedError) {
            // Do nothing allow error correction to happen
          } else {
            throw enhanceError(e, ai, this.signature)
          }

          if (errorFields) {
            handleValidationError(
              mem,
              errorFields,
              ai,
              this.promptTemplate,
              options.sessionId
            )
          }
        }
      }

      throw enhanceError(
        new Error(`Unable to fix validation error: ${err?.toString()}`),
        ai,
        this.signature
      )
    }

    throw enhanceError(
      new Error(`Max steps reached: ${maxSteps}`),
      ai,
      this.signature
    )
  }

  private shouldContinueSteps(
    lastMemItem: ReturnType<AxAIMemory['getLast']>,
    stopFunction: string | undefined
  ) {
    const stopFunctionExecuted =
      stopFunction && this.functionsExecuted.has(stopFunction)

    const isFunction = lastMemItem?.chat?.role === 'function'
    const isProcessor = lastMemItem?.tags
      ? lastMemItem.tags.some((tag) => tag === 'processor')
      : false

    if (isFunction && stopFunction && stopFunctionExecuted) {
      return false
    }

    if (isFunction || isProcessor) {
      return true
    }

    return false
  }

  public async *_forward1(
    ai: Readonly<AxAIService>,
    values: IN,
    options: Readonly<AxProgramForwardOptions>
  ) {
    const tracer =
      options?.tracer ?? this.options?.tracer ?? ai.getOptions().tracer

    let functions: AxFunction[] | undefined = this.functions

    if (options?.functions) {
      functions = parseFunctions(options.functions, this.functions)
    }

    if (!tracer) {
      yield* this._forward2(ai, values, {
        ...options,
        functions,
      })
      return
    }

    const funcNames = functions?.map((f) => f.name).join(',')

    const attributes = {
      signature: JSON.stringify(this.signature.toJSON(), null, 2),
      ...(this.examples
        ? { examples: JSON.stringify(this.examples, null, 2) }
        : {}),
      ...(funcNames ? { provided_functions: funcNames } : {}),
      ...(options?.model ? { model: options.model } : {}),
      ...(options?.thinkingTokenBudget
        ? { thinking_token_budget: options.thinkingTokenBudget }
        : {}),
      ...(options?.showThoughts ? { show_thoughts: options.showThoughts } : {}),
      ...(options?.maxSteps ? { max_steps: options.maxSteps } : {}),
      ...(options?.maxRetries ? { max_retries: options.maxRetries } : {}),
      ...(options?.fastFail ? { fast_fail: options.fastFail } : {}),
    }

    const traceLabel = options.traceLabel ?? this.options?.traceLabel
    const spanName = traceLabel ? `${traceLabel} (AxGen)` : 'AxGen'

    const span = tracer.startSpan(spanName, {
      kind: SpanKind.SERVER,
      attributes,
    })

    const currentContext = context.active()
    const traceContext = trace.setSpan(currentContext, span)

    try {
      if (!this.excludeContentFromTrace) {
        span.addEvent('input', { content: JSON.stringify(values, null, 2) })
      }

      yield* this._forward2(
        ai,
        values,
        {
          ...options,
          functions,
        },
        span,
        traceContext
      )

      if (!this.excludeContentFromTrace) {
        span.addEvent('output', {
          content: JSON.stringify(this.values, null, 2),
        })
      }
    } finally {
      span.end()
    }
  }

  public override async forward(
    ai: Readonly<AxAIService>,
    values: IN,
    options?: Readonly<AxProgramForwardOptions>
  ): Promise<OUT> {
    const generator = this._forward1(ai, values, options ?? {})

    let buffer = {} as AxGenDeltaOut<OUT>['delta']
    let currentVersion = 0

    for await (const item of generator) {
      if (item.version !== currentVersion) {
        buffer = {}
      }
      currentVersion = item.version
      buffer = mergeDeltas(buffer, item.delta)
    }

    this.trace = { ...values, ...buffer }
    return buffer as OUT
  }

  override async *streamingForward(
    ai: Readonly<AxAIService>,
    values: IN,
    options?: Readonly<AxProgramStreamingForwardOptions>
  ) {
    yield* this._forward1(ai, values, {
      ...options,
      stream: true,
    })
  }

  public override setExamples(
    examples: Readonly<AxProgramExamples>,
    options?: Readonly<AxSetExamplesOptions>
  ) {
    super.setExamples(examples, options)
    // No need to update prompt template - all fields can be missing in examples
  }
}

export type AxGenerateErrorDetails = {
  model?: string
  maxTokens?: number
  streaming: boolean
  signature: {
    input: Readonly<AxIField[]>
    output: Readonly<AxIField[]>
    description?: string
  }
}

export class AxGenerateError extends Error {
  public readonly details: AxGenerateErrorDetails

  constructor(
    message: string,
    details: Readonly<AxGenerateErrorDetails>,
    options?: ErrorOptions
  ) {
    super(message, options)
    this.name = 'AxGenerateError'
    this.details = details
  }
}

function enhanceError(
  e: unknown,
  ai: Readonly<AxAIService>,
  signature: Readonly<AxSignature>
): Error {
  const originalError = e instanceof Error ? e : new Error(String(e))
  const model = ai.getLastUsedChatModel() as string | undefined
  const modelConfig = ai.getLastUsedModelConfig()

  const details = {
    model: model,
    maxTokens: modelConfig?.maxTokens,
    streaming: modelConfig?.stream ?? false,
    signature: {
      input: signature.getInputFields(),
      output: signature.getOutputFields(),
      description: signature.getDescription(),
    },
  }

  // Return custom error with short message and details as object property
  return new AxGenerateError('Generate failed', details, {
    cause: originalError,
  })
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/mipro.ts
```ts
import type { AxAIService } from '../ai/types.js'

import {
  AxBootstrapFewShot,
  type AxExample,
  type AxMetricFn,
  type AxOptimizerArgs,
} from './optimize.js'
import type {
  AxProgram,
  AxProgramDemos,
  AxProgramWithSignature,
} from './program.js'
import type { AxGenIn, AxGenOut } from './types.js'
import { updateProgressBar } from './util.js'

export interface AxMiPROOptions {
  numCandidates?: number
  initTemperature?: number
  maxBootstrappedDemos?: number
  maxLabeledDemos?: number
  numTrials?: number
  minibatch?: boolean
  minibatchSize?: number
  minibatchFullEvalSteps?: number
  programAwareProposer?: boolean
  dataAwareProposer?: boolean
  viewDataBatchSize?: number
  tipAwareProposer?: boolean
  fewshotAwareProposer?: boolean
  seed?: number
  verbose?: boolean
  earlyStoppingTrials?: number
  minImprovementThreshold?: number
}

interface ConfigType {
  instruction: string
  bootstrappedDemos: number
  labeledExamples: number
}

interface ConfigPoint {
  config: ConfigType
  score: number
}

export class AxMiPRO<
  IN extends AxGenIn = AxGenIn,
  OUT extends AxGenOut = AxGenOut,
> {
  private ai: AxAIService
  private program: Readonly<AxProgram<IN, OUT>>
  private examples: readonly AxExample[]
  private maxBootstrappedDemos: number
  private maxLabeledDemos: number
  private numCandidates: number
  private initTemperature: number
  private numTrials: number
  private minibatch: boolean
  private minibatchSize: number
  private minibatchFullEvalSteps: number
  private programAwareProposer: boolean
  private dataAwareProposer: boolean
  private viewDataBatchSize: number
  private tipAwareProposer: boolean
  private fewshotAwareProposer: boolean
  private seed?: number
  private verbose: boolean
  private bootstrapper: AxBootstrapFewShot<IN, OUT>
  private earlyStoppingTrials: number
  private minImprovementThreshold: number

  constructor({
    ai,
    program,
    examples = [],
    options,
  }: Readonly<AxOptimizerArgs<IN, OUT>> & { options?: AxMiPROOptions }) {
    if (examples.length === 0) {
      throw new Error('No examples found')
    }

    const miproOptions = (options as AxMiPROOptions) || {}

    this.numCandidates = miproOptions.numCandidates ?? 5
    this.initTemperature = miproOptions.initTemperature ?? 0.7
    this.maxBootstrappedDemos = miproOptions.maxBootstrappedDemos ?? 3
    this.maxLabeledDemos = miproOptions.maxLabeledDemos ?? 4
    this.numTrials = miproOptions.numTrials ?? 30
    this.minibatch = miproOptions.minibatch ?? true
    this.minibatchSize = miproOptions.minibatchSize ?? 25
    this.minibatchFullEvalSteps = miproOptions.minibatchFullEvalSteps ?? 10
    this.programAwareProposer = miproOptions.programAwareProposer ?? true
    this.dataAwareProposer = miproOptions.dataAwareProposer ?? true
    this.viewDataBatchSize = miproOptions.viewDataBatchSize ?? 10
    this.tipAwareProposer = miproOptions.tipAwareProposer ?? true
    this.fewshotAwareProposer = miproOptions.fewshotAwareProposer ?? true
    this.seed = miproOptions.seed
    this.verbose = miproOptions.verbose ?? false
    this.earlyStoppingTrials = miproOptions.earlyStoppingTrials ?? 5
    this.minImprovementThreshold = miproOptions.minImprovementThreshold ?? 0.01

    this.ai = ai
    this.program = program
    this.examples = examples

    // Initialize the bootstrapper to handle few-shot example generation
    this.bootstrapper = new AxBootstrapFewShot<IN, OUT>({
      ai,
      program,
      examples,
      options: {
        maxDemos: this.maxBootstrappedDemos,
        maxRounds: 3, // Default, or adjust based on your needs
        verboseMode: this.verbose,
      },
    })
  }

  /**
   * Configures the optimizer for light, medium, or heavy optimization
   * @param level The optimization level: "light", "medium", or "heavy"
   */
  public configureAuto(level: 'light' | 'medium' | 'heavy'): void {
    switch (level) {
      case 'light':
        this.numCandidates = 3
        this.numTrials = 10
        this.minibatch = true
        this.minibatchSize = 20
        break
      case 'medium':
        this.numCandidates = 5
        this.numTrials = 20
        this.minibatch = true
        this.minibatchSize = 25
        break
      case 'heavy':
        this.numCandidates = 7
        this.numTrials = 30
        this.minibatch = true
        this.minibatchSize = 30
        break
    }
  }

  /**
   * Generates creative tips for instruction generation
   */
  private generateTips(): string[] {
    return [
      'Be very specific and detailed in your instructions.',
      'Focus on step-by-step reasoning in your instructions.',
      'Provide clear constraints and guidelines in your instructions.',
      'Keep your instructions concise and to the point.',
      'Emphasize accuracy and precision in your instructions.',
      'Include examples of good outputs in your instructions.',
      'Focus on handling edge cases in your instructions.',
      'Explicitly outline the reasoning process in your instructions.',
    ]
  }

  /**
   * Generates instruction candidates for each predictor in the program
   * @returns Array of generated instruction candidates
   */
  private async proposeInstructionCandidates(): Promise<string[]> {
    const instructions: string[] = []

    // Get a summary of the program for program-aware proposing
    let programContext = ''
    if (this.programAwareProposer) {
      programContext = await this.generateProgramSummary()
    }

    // Get a summary of the dataset for data-aware proposing
    let dataContext = ''
    if (this.dataAwareProposer) {
      dataContext = await this.generateDataSummary()
    }

    // Generate random tips for tip-aware proposing
    const tips = this.tipAwareProposer ? this.generateTips() : []

    // Generate instructions for each candidate
    for (let i = 0; i < this.numCandidates; i++) {
      const tipIndex = tips.length > 0 ? i % tips.length : -1
      const tipToUse = tipIndex >= 0 ? tips[tipIndex] : ''

      const instruction = await this.generateInstruction({
        programContext,
        dataContext,
        tip: tipToUse,
        candidateIndex: i,
      })

      instructions.push(instruction)
    }

    return instructions
  }

  /**
   * Generates a summary of the program structure for instruction proposal
   */
  private async generateProgramSummary(): Promise<string> {
    // In a real implementation, this would analyze the program's structure
    // and generate a summary of its components, signatures, etc.
    const prompt = `Summarize the following program structure. Focus on the signatures, 
      input/output fields, and the purpose of each component. Identify key components 
      that might benefit from better instructions.`

    const programStr = JSON.stringify(this.program)

    const response = await this.ai.chat({
      chatPrompt: [
        { role: 'system', content: prompt },
        { role: 'user', content: programStr },
      ],
      modelConfig: { temperature: 0.2 },
    })

    // Handle both sync and async responses
    if (response instanceof ReadableStream) {
      return ''
    }

    return response.results[0]?.content || ''
  }

  /**
   * Generates a summary of the dataset for instruction proposal
   */
  private async generateDataSummary(): Promise<string> {
    // Sample a subset of examples for analysis
    const sampleSize = Math.min(this.viewDataBatchSize, this.examples.length)
    const sample = this.examples.slice(0, sampleSize)

    const prompt = `Analyze the following dataset examples and provide a summary 
      of key patterns, input-output relationships, and any specific challenges 
      the data presents. Focus on what makes a good answer and what patterns should
      be followed.`

    const dataStr = JSON.stringify(sample)

    const response = await this.ai.chat({
      chatPrompt: [
        { role: 'system', content: prompt },
        { role: 'user', content: dataStr },
      ],
      modelConfig: { temperature: 0.2 },
    })

    // Handle both sync and async responses
    if (response instanceof ReadableStream) {
      return ''
    }

    return response.results[0]?.content || ''
  }

  /**
   * Generates a specific instruction candidate
   */
  private async generateInstruction({
    programContext,
    dataContext,
    tip,
    candidateIndex,
  }: Readonly<{
    programContext: string
    dataContext: string
    tip: string | undefined
    candidateIndex: number
  }>): Promise<string> {
    const prompt = `Create a high-quality instruction for an AI model performing the task described below.
    
    ${programContext ? `PROGRAM CONTEXT:\n${programContext}\n\n` : ''}
    ${dataContext ? `DATA CONTEXT:\n${dataContext}\n\n` : ''}
    ${tip ? `STYLE TIP: ${tip}\n\n` : ''}
    
    Your task is to craft a clear, effective instruction that will help the AI model generate
    accurate outputs for this task. Instruction #${candidateIndex + 1}/${this.numCandidates}.
    
    The instruction should be detailed enough to guide the model but not overly prescriptive
    or restrictive. Focus on what makes a good response rather than listing exact steps.
    
    INSTRUCTION:`

    const response = await this.ai.chat({
      chatPrompt: [{ role: 'user', content: prompt }],
      modelConfig: { temperature: 0.7 + 0.1 * candidateIndex },
    })

    // Handle both sync and async responses
    if (response instanceof ReadableStream) {
      return ''
    }

    return response.results[0]?.content || ''
  }

  /**
   * Bootstraps few-shot examples for the program
   */
  private async bootstrapFewShotExamples(
    metricFn: AxMetricFn
  ): Promise<AxProgramDemos[]> {
    if (this.verbose) {
      console.log('Bootstrapping few-shot examples...')
    }

    const result = await this.bootstrapper.compile(metricFn, {
      maxDemos: this.maxBootstrappedDemos,
    })

    return result.demos
  }

  /**
   * Selects labeled examples directly from the training set
   */
  private selectLabeledExamples(): AxExample[] {
    const selectedExamples: AxExample[] = []

    // Random sampling from the training set
    const indices = new Set<number>()
    while (
      indices.size < this.maxLabeledDemos &&
      indices.size < this.examples.length
    ) {
      const idx = Math.floor(Math.random() * this.examples.length)
      if (!indices.has(idx)) {
        indices.add(idx)
        const example = this.examples[idx]
        if (example) {
          selectedExamples.push(example)
        }
      }
    }

    return selectedExamples
  }

  /**
   * Runs Bayesian optimization to find the best combination of few-shot examples and instructions
   */
  private async runBayesianOptimization(
    bootstrappedDemos: readonly AxProgramDemos[],
    labeledExamples: readonly AxExample[],
    instructions: readonly string[],
    valset: readonly AxExample[],
    metricFn: AxMetricFn
  ): Promise<{ bestConfig: ConfigType; bestScore: number }> {
    let bestConfig: ConfigType | null = null
    let bestScore = Number.NEGATIVE_INFINITY

    // Track all evaluated configurations for Bayesian optimization
    const evaluatedConfigs: ConfigPoint[] = []

    // Add a default fallback configuration in case all evaluations fail
    const defaultConfig: ConfigType = {
      instruction: instructions[0] || '',
      bootstrappedDemos: Math.min(1, bootstrappedDemos.length),
      labeledExamples: Math.min(1, labeledExamples.length),
    }

    // Track early stopping conditions
    let trialsWithoutImprovement = 0
    let lastBestScore = Number.NEGATIVE_INFINITY

    // Initial random exploration phase (to build a model)
    const initialExplorationTrials = Math.min(
      10,
      Math.floor(this.numTrials / 3)
    )

    const configs: ConfigType[] = []

    // Initial exploration - generate random configurations
    for (let i = 0; i < initialExplorationTrials; i++) {
      const instructionIndex = Math.floor(Math.random() * instructions.length)
      const instructionValue = instructions[instructionIndex] || ''

      const config: ConfigType = {
        instruction: instructionValue,
        bootstrappedDemos: Math.floor(
          Math.random() * (bootstrappedDemos.length + 1)
        ),
        labeledExamples: Math.floor(
          Math.random() * (labeledExamples.length + 1)
        ),
      }
      configs.push(config)
    }

    // Evaluate initial configurations
    for (let i = 0; i < configs.length; i++) {
      const config = configs[i]
      if (!config) continue

      const score = await this.evaluateConfig(
        config,
        bootstrappedDemos,
        labeledExamples,
        valset,
        metricFn,
        i
      )

      evaluatedConfigs.push({ config, score })

      if (score > bestScore) {
        bestScore = score
        bestConfig = config

        if (this.verbose) {
          console.log(
            `New best configuration found with score ${bestScore} (exploration phase)`
          )
        }
      }

      // Update progress
      updateProgressBar(
        i + 1,
        this.numTrials,
        Math.round(bestScore * 100),
        0,
        'Running MIPROv2 optimization',
        30
      )
    }

    // Exploitation phase - use Bayesian optimization
    for (let i = configs.length; i < this.numTrials; i++) {
      // Generate a new configuration using acquisition function
      const nextConfig = this.selectNextConfiguration(
        evaluatedConfigs,
        bootstrappedDemos.length,
        labeledExamples.length,
        instructions
      )

      // Evaluate the configuration
      const score = await this.evaluateConfig(
        nextConfig,
        bootstrappedDemos,
        labeledExamples,
        valset,
        metricFn,
        i
      )

      evaluatedConfigs.push({ config: nextConfig, score })

      // Check if this is a new best configuration
      if (score > bestScore) {
        bestScore = score
        bestConfig = nextConfig

        if (this.verbose) {
          console.log(
            `New best configuration found with score ${bestScore} (exploitation phase)`
          )
        }

        // Reset early stopping counter
        trialsWithoutImprovement = 0
        lastBestScore = bestScore
      } else {
        // Check early stopping condition
        if (bestScore - lastBestScore < this.minImprovementThreshold) {
          trialsWithoutImprovement++

          if (trialsWithoutImprovement >= this.earlyStoppingTrials) {
            if (this.verbose) {
              console.log(
                `Early stopping triggered after ${i + 1} trials. No improvement for ${trialsWithoutImprovement} trials.`
              )
            }
            break
          }
        } else {
          // There was some improvement, but not enough to be the best
          lastBestScore = bestScore
          trialsWithoutImprovement = 0
        }
      }

      // Update progress
      updateProgressBar(
        i + 1,
        this.numTrials,
        Math.round(bestScore * 100),
        0,
        'Running MIPROv2 optimization',
        30
      )

      // Run full evaluation on best config periodically
      if (
        this.minibatch &&
        i > 0 &&
        (i + 1) % this.minibatchFullEvalSteps === 0 &&
        bestConfig
      ) {
        if (this.verbose) {
          console.log(
            `Running full evaluation on best configuration at trial ${i + 1}`
          )
        }

        const fullScore = await this.fullEvaluation(
          bestConfig,
          bootstrappedDemos,
          labeledExamples,
          valset,
          metricFn
        )

        if (this.verbose) {
          console.log(`Full evaluation score: ${fullScore}`)
        }

        // Update best score based on full evaluation
        bestScore = fullScore
      }
    }

    if (!bestConfig) {
      if (this.verbose) {
        console.warn(
          'Optimization failed to find any valid configurations, using default fallback configuration'
        )
      }
      bestConfig = defaultConfig

      // Try to evaluate the default config as a last resort
      try {
        bestScore = await this.evaluateConfig(
          bestConfig,
          bootstrappedDemos,
          labeledExamples,
          valset,
          metricFn,
          this.numTrials - 1
        )
      } catch (err) {
        if (this.verbose) {
          console.error('Error evaluating default configuration:', err)
        }
        bestScore = 0 // Set a minimal score as fallback
      }
    }

    return { bestConfig, bestScore }
  }

  /**
   * Evaluates a configuration on the validation set
   */
  private async evaluateConfig(
    config: Readonly<ConfigType>,
    bootstrappedDemos: readonly AxProgramDemos[],
    labeledExamples: readonly AxExample[],
    valset: readonly AxExample[],
    metricFn: AxMetricFn,
    trialIndex: number
  ): Promise<number> {
    // Create a new instance for evaluation with proper cloning

    // Apply configuration to program
    this.applyConfigToProgram(
      this.program,
      config,
      bootstrappedDemos,
      labeledExamples
    )

    // Determine which examples to use for evaluation
    let evalSet: readonly AxExample[] = valset
    if (this.minibatch) {
      // Use minibatch for faster evaluation during trials
      const startIdx = (trialIndex * this.minibatchSize) % valset.length
      const minibatchEvalSet: AxExample[] = []
      for (let j = 0; j < this.minibatchSize; j++) {
        const idx = (startIdx + j) % valset.length
        const example = valset[idx]
        if (example) {
          minibatchEvalSet.push(example)
        }
      }
      evalSet = minibatchEvalSet
    }

    // Evaluate the configuration
    let sumOfScores = 0
    for (const example of evalSet) {
      try {
        const prediction = await this.program.forward(this.ai, example as IN)
        const score = metricFn({ prediction, example })
        sumOfScores += score
      } catch (err) {
        if (this.verbose) {
          console.error('Error evaluating example:', err)
        }
      }
    }
    if (evalSet.length === 0) return 0 // Avoid division by zero
    return sumOfScores / evalSet.length
  }

  /**
   * Run full evaluation on the entire validation set
   */
  private async fullEvaluation(
    config: Readonly<ConfigType>,
    bootstrappedDemos: readonly AxProgramDemos[],
    labeledExamples: readonly AxExample[],
    valset: readonly AxExample[],
    metricFn: AxMetricFn
  ): Promise<number> {
    this.applyConfigToProgram(
      this.program,
      config,
      bootstrappedDemos,
      labeledExamples
    )

    let sumOfScores = 0
    for (const example of valset) {
      try {
        const prediction = await this.program.forward(this.ai, example as IN)
        const score = metricFn({ prediction, example })
        sumOfScores += score
      } catch (err) {
        if (this.verbose) {
          console.error('Error evaluating example:', err)
        }
      }
    }
    if (valset.length === 0) return 0 // Avoid division by zero
    return sumOfScores / valset.length
  }

  /**
   * Implements a Bayesian-inspired selection of the next configuration to try
   * This is a simplified version using Upper Confidence Bound (UCB) strategy
   */
  private selectNextConfiguration(
    evaluatedConfigs: ConfigPoint[],
    maxBootstrappedDemos: number,
    maxLabeledExamples: number,
    instructions: readonly string[]
  ): ConfigType {
    // If we don't have many evaluations yet, use random exploration with a bias towards good configs
    if (evaluatedConfigs.length < 5) {
      const instructionIndex = Math.floor(Math.random() * instructions.length)
      return {
        instruction: instructions[instructionIndex] || '',
        bootstrappedDemos: Math.floor(
          Math.random() * (maxBootstrappedDemos + 1)
        ),
        labeledExamples: Math.floor(Math.random() * (maxLabeledExamples + 1)),
      }
    }

    // Sort configurations by score
    const sortedConfigs = [...evaluatedConfigs].sort(
      (a, b) => b.score - a.score
    )

    // Top performing configurations to learn from
    const topConfigs = sortedConfigs.slice(0, Math.min(3, sortedConfigs.length))

    // Calculate mean and variance of parameters in top configurations
    const meanBootstrappedDemos =
      topConfigs.reduce((sum, c) => sum + c.config.bootstrappedDemos, 0) /
      topConfigs.length
    const meanLabeledExamples =
      topConfigs.reduce((sum, c) => sum + c.config.labeledExamples, 0) /
      topConfigs.length

    // Get popular instructions among top performers
    const popularInstructions = topConfigs.map((c) => c.config.instruction)

    // Exploration factor decreases over time
    const explorationFactor = Math.max(
      0.2,
      1.0 - evaluatedConfigs.length / this.numTrials
    )

    // Generate a new configuration with exploitation (using learned info) + exploration (random variations)
    let newBootstrappedDemos: number
    let newLabeledExamples: number
    let newInstruction: string

    // Decide whether to exploit or explore for bootstrapped demos
    if (Math.random() < 0.7) {
      // 70% chance to exploit
      // Sample around the mean of top configs with some noise
      newBootstrappedDemos = Math.min(
        maxBootstrappedDemos,
        Math.max(
          0,
          Math.round(
            meanBootstrappedDemos +
              (Math.random() * 2 - 1) * explorationFactor * 2
          )
        )
      )
    } else {
      // Random exploration
      newBootstrappedDemos = Math.floor(
        Math.random() * (maxBootstrappedDemos + 1)
      )
    }

    // Same for labeled examples
    if (Math.random() < 0.7) {
      newLabeledExamples = Math.min(
        maxLabeledExamples,
        Math.max(
          0,
          Math.round(
            meanLabeledExamples +
              (Math.random() * 2 - 1) * explorationFactor * 2
          )
        )
      )
    } else {
      newLabeledExamples = Math.floor(Math.random() * (maxLabeledExamples + 1))
    }

    // For instructions, either pick from top performers or try a new one
    if (Math.random() < 0.7 && popularInstructions.length > 0) {
      const idx = Math.floor(Math.random() * popularInstructions.length)
      newInstruction = popularInstructions[idx] || ''
    } else {
      const idx = Math.floor(Math.random() * instructions.length)
      newInstruction = instructions[idx] || ''
    }

    return {
      instruction: newInstruction,
      bootstrappedDemos: newBootstrappedDemos,
      labeledExamples: newLabeledExamples,
    }
  }

  /**
   * Applies a configuration to a program instance
   */
  private applyConfigToProgram(
    program: Readonly<AxProgram<IN, OUT>>,
    config: Readonly<ConfigType>,
    bootstrappedDemos: readonly AxProgramDemos[],
    labeledExamples: readonly AxExample[]
  ): void {
    // Set instruction
    this.setInstructionToProgram(program, config.instruction)

    // Set demos if needed
    if (config.bootstrappedDemos > 0) {
      program.setDemos(bootstrappedDemos.slice(0, config.bootstrappedDemos))
    }

    // Set examples if needed
    if (config.labeledExamples > 0) {
      program.setExamples(labeledExamples.slice(0, config.labeledExamples))
    }
  }

  /**
   * Sets instruction to a program
   * Note: Workaround since setInstruction may not be available directly
   */
  private setInstructionToProgram(
    program: Readonly<AxProgram<IN, OUT>>,
    instruction: string
  ): void {
    if ('getSignature' in program) {
      const programWithSig = program as AxProgramWithSignature<IN, OUT>
      programWithSig.getSignature().setDescription(instruction)
    }
  }

  /**
   * The main compile method to run MIPROv2 optimization
   * @param metricFn Evaluation metric function
   * @param options Optional configuration options
   * @returns The optimized program
   */
  public async compile(
    metricFn: AxMetricFn,
    options?: Readonly<{
      valset?: readonly AxExample[]
      teacher?: Readonly<AxProgram<IN, OUT>>
      auto?: 'light' | 'medium' | 'heavy'
    }>
  ): Promise<Readonly<AxProgram<IN, OUT>>> {
    // Configure auto settings if provided
    if (options?.auto) {
      this.configureAuto(options.auto)
    }

    // Split data into train and validation sets if valset not provided
    const trainset = this.examples
    const valset =
      options?.valset ||
      this.examples.slice(0, Math.floor(this.examples.length * 0.8))

    if (this.verbose) {
      console.log(`Starting MIPROv2 optimization with ${this.numTrials} trials`)
      console.log(
        `Using ${trainset.length} examples for training and ${valset.length} for validation`
      )
    }

    // If teacher is provided, use it to help bootstrap examples
    if (options?.teacher) {
      if (this.verbose) {
        console.log('Using provided teacher to assist with bootstrapping')
      }

      // Create a copy of the bootstrapper with the teacher AI
      const bootstrapperWithTeacher = new AxBootstrapFewShot<IN, OUT>({
        ai: this.ai,
        program: this.program,
        examples: this.examples,
        options: {
          maxDemos: this.maxBootstrappedDemos,
          maxRounds: 3,
          verboseMode: this.verbose,
          teacherAI: this.ai, // Use the same AI but with the teacher program
        },
      })

      // Replace the existing bootstrapper
      this.bootstrapper = bootstrapperWithTeacher
    }

    // Step 1: Bootstrap few-shot examples
    let bootstrappedDemos: AxProgramDemos[] = []
    if (this.maxBootstrappedDemos > 0) {
      bootstrappedDemos = await this.bootstrapFewShotExamples(metricFn)

      if (this.verbose) {
        console.log(
          `Generated ${bootstrappedDemos.length} bootstrapped demonstrations`
        )
      }
    }

    // Step 2: Select labeled examples from training set
    let labeledExamples: AxExample[] = []
    if (this.maxLabeledDemos > 0) {
      labeledExamples = this.selectLabeledExamples()

      if (this.verbose) {
        console.log(
          `Selected ${labeledExamples.length} labeled examples from training set`
        )
      }
    }

    // Step 3: Generate instruction candidates
    const instructions = await this.proposeInstructionCandidates()

    if (this.verbose) {
      console.log(`Generated ${instructions.length} instruction candidates`)
    }

    // Step 4: Run Bayesian optimization to find the best configuration
    const { bestConfig, bestScore } = await this.runBayesianOptimization(
      bootstrappedDemos,
      labeledExamples,
      instructions,
      valset,
      metricFn
    )

    if (this.verbose) {
      console.log(`Optimization complete. Best score: ${bestScore}`)
      console.log(`Best configuration: ${JSON.stringify(bestConfig)}`)
    }

    // Apply the best configuration to a fresh copy of the program
    this.applyConfigToProgram(
      this.program,
      bestConfig,
      bootstrappedDemos,
      labeledExamples
    )

    return this.program
  }
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/program.ts
```ts
import type { Tracer } from '@opentelemetry/api'

import type {
  AxAIService,
  AxChatRequest,
  AxChatResponse,
  AxLoggerFunction,
  AxModelConfig,
  AxRateLimiterFunction,
} from '../ai/types.js'
import type { AxAIMemory } from '../mem/types.js'

import type { AxInputFunctionType } from './functions.js'
import { AxInstanceRegistry } from './registry.js'
import { type AxField, AxSignature } from './sig.js'
import type { AxFieldValue, AxGenIn, AxGenOut, AxMessage } from './types.js'
import { mergeProgramUsage, validateValue } from './util.js'

export type AxProgramTrace = {
  //   examples: Record<string, Value>[];
  trace: Record<string, AxFieldValue>
  programId: string
}

export type AxProgramDemos = {
  //   examples: Record<string, Value>[];
  traces: Record<string, AxFieldValue>[]
  programId: string
}

export type AxProgramExamples = AxProgramDemos | AxProgramDemos['traces']

export type AxProgramForwardOptions = {
  maxRetries?: number
  maxSteps?: number
  mem?: AxAIMemory
  ai?: AxAIService
  modelConfig?: AxModelConfig
  model?: string
  sessionId?: string
  traceId?: string | undefined
  tracer?: Tracer
  rateLimiter?: AxRateLimiterFunction
  stream?: boolean
  functions?: AxInputFunctionType
  functionCall?: AxChatRequest['functionCall']
  stopFunction?: string
  fastFail?: boolean
  debug?: boolean
  debugHideSystemPrompt?: boolean
  thinkingTokenBudget?:
    | 'minimal'
    | 'low'
    | 'medium'
    | 'high'
    | 'highest'
    | 'none'
  showThoughts?: boolean
  traceLabel?: string
  abortSignal?: AbortSignal
  logger?: AxLoggerFunction
}

export type AxProgramStreamingForwardOptions = Omit<
  AxProgramForwardOptions,
  'stream'
>

export type AxGenDeltaOut<OUT extends AxGenOut> = {
  version: number
  delta: Partial<OUT>
}

export type AxGenStreamingOut<OUT extends AxGenOut> = AsyncGenerator<
  AxGenDeltaOut<OUT>,
  // biome-ignore lint/suspicious/noConfusingVoidType: just cause
  void | OUT,
  unknown
>

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export type AxSetExamplesOptions = {
  // No options needed - all fields can be missing in examples
}

export interface AxTunable {
  setExamples: (
    examples: Readonly<AxProgramExamples>,
    options?: Readonly<AxSetExamplesOptions>
  ) => void
  setId: (id: string) => void
  setParentId: (parentId: string) => void
  getTraces: () => AxProgramTrace[]
  setDemos: (demos: readonly AxProgramDemos[]) => void
}

export interface AxUsable {
  getUsage: () => AxProgramUsage[]
  resetUsage: () => void
}

export type AxProgramUsage = AxChatResponse['modelUsage'] & {
  ai: string
  model: string
}

export interface AxProgramWithSignatureOptions {
  description?: string
}

export class AxProgramWithSignature<
    IN extends AxGenIn | ReadonlyArray<AxMessage>,
    OUT extends AxGenOut,
  >
  implements AxTunable, AxUsable
{
  protected signature: AxSignature
  protected sigHash: string

  protected examples?: Record<string, AxFieldValue>[]
  protected examplesOptions?: AxSetExamplesOptions
  protected demos?: Record<string, AxFieldValue>[]
  protected trace?: Record<string, AxFieldValue>
  protected usage: AxProgramUsage[] = []
  protected scope: Map<string, { field: AxField<any>; value: AxFieldValue }> =
    new Map()

  private key: { id: string; custom?: boolean }
  private children: AxInstanceRegistry<Readonly<AxTunable & AxUsable>>

  constructor(
    signature: Readonly<AxSignature>,
    options?: Readonly<AxProgramWithSignatureOptions>
  ) {
    this.signature = new AxSignature(signature)
    this.sigHash = this.signature?.hash()
    this.children = new AxInstanceRegistry()
    this.key = { id: this.constructor.name }

    if (options?.description) {
      this.signature.setDescription(options.description)
    }
  }

  public getSignature() {
    return this.signature
  }

  public updateScope(field: AxField<any>, value?: AxFieldValue) {
    if (value === null || value === undefined) {
      this.scope.delete(field.name)
    } else {
      this.scope.set(field.name, { field, value })
    }
  }

  public getScope(): Readonly<
    Map<string, { field: AxField<any>; value: AxFieldValue }>
  > {
    return this.scope
  }

  public register(prog: Readonly<AxTunable & AxUsable>) {
    if (this.key) {
      prog.setParentId(this.key.id)
    }
    this.children.register(prog)
  }

  public async forward(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _ai: Readonly<AxAIService>,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _values: IN,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _options?: Readonly<AxProgramForwardOptions>
  ): Promise<OUT> {
    throw new Error('forward() not implemented')
  }

  // biome-ignore lint/correctness/useYield: just a placeholder
  public async *streamingForward(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _ai: Readonly<AxAIService>,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _values: IN,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _options?: Readonly<AxProgramStreamingForwardOptions>
  ): AxGenStreamingOut<OUT> {
    throw new Error('streamingForward() not implemented')
  }

  public setId(id: string) {
    this.key = { id, custom: true }
    for (const child of this.children) {
      child.setParentId(id)
    }
  }

  public setParentId(parentId: string) {
    if (!this.key.custom) {
      this.key.id = [parentId, this.key.id].join('/')
    }
  }

  public setExamples(
    examples: Readonly<AxProgramExamples>,
    options?: Readonly<AxSetExamplesOptions>
  ) {
    this._setExamples(examples, options)

    if (!('programId' in examples)) {
      return
    }

    for (const child of this.children) {
      child.setExamples(examples, options)
    }
  }

  private _setExamples(
    examples: Readonly<AxProgramExamples>,
    options?: Readonly<AxSetExamplesOptions>
  ) {
    let traces: Record<string, AxFieldValue>[] = []

    if ('programId' in examples && examples.programId === this.key.id) {
      traces = examples.traces
    }

    if (Array.isArray(examples)) {
      traces = examples
    }

    if (traces) {
      this.examplesOptions = options
      const sig = this.signature
      const fields = [...sig.getInputFields(), ...sig.getOutputFields()]

      this.examples = traces.map((e) => {
        const res: Record<string, AxFieldValue> = {}
        for (const f of fields) {
          const value = e[f.name]
          if (value !== undefined) {
            // Only validate the type of fields that are actually set
            // Allow any field to be missing regardless of whether it's required
            validateValue(f, value)
            res[f.name] = value
          }
        }
        return res
      })
    }
  }

  public getTraces(): AxProgramTrace[] {
    let traces: AxProgramTrace[] = []

    if (this.trace) {
      traces.push({ trace: this.trace, programId: this.key.id })
    }

    for (const child of this.children) {
      const _traces = child.getTraces()
      traces = [...traces, ..._traces]
    }
    return traces
  }

  public getUsage(): AxProgramUsage[] {
    let usage: AxProgramUsage[] = [...(this.usage ?? [])]

    for (const child of this.children) {
      const cu = child.getUsage()
      usage = [...usage, ...cu]
    }
    return mergeProgramUsage(usage)
  }

  public resetUsage() {
    this.usage = []
    for (const child of this.children) {
      child.resetUsage()
    }
  }

  public setDemos(demos: readonly AxProgramDemos[]) {
    // biome-ignore lint/complexity/useFlatMap: it can't
    this.demos = demos
      .filter((v) => v.programId === this.key.id)
      .map((v) => v.traces)
      .flat()

    for (const child of this.children) {
      child.setDemos(demos)
    }
  }
}

export class AxProgram<IN extends AxGenIn, OUT extends AxGenOut>
  implements AxTunable, AxUsable
{
  protected trace?: Record<string, AxFieldValue>
  protected usage: AxProgramUsage[] = []

  private key: { id: string; custom?: boolean }
  private children: AxInstanceRegistry<Readonly<AxTunable & AxUsable>>

  constructor() {
    this.children = new AxInstanceRegistry()
    this.key = { id: this.constructor.name }
  }

  public register(prog: Readonly<AxTunable & AxUsable>) {
    if (this.key) {
      prog.setParentId(this.key.id)
    }
    this.children.register(prog)
  }

  public async forward(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _ai: Readonly<AxAIService>,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _values: IN,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _options?: Readonly<AxProgramForwardOptions>
  ): Promise<OUT> {
    throw new Error('forward() not implemented')
  }

  // biome-ignore lint/correctness/useYield: just a placeholder
  public async *streamingForward(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _ai: Readonly<AxAIService>,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _values: IN,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _options?: Readonly<AxProgramStreamingForwardOptions>
  ): AxGenStreamingOut<OUT> {
    throw new Error('streamingForward() not implemented')
  }

  public setId(id: string) {
    this.key = { id, custom: true }
    for (const child of this.children) {
      child.setParentId(id)
    }
  }

  public setParentId(parentId: string) {
    if (!this.key.custom) {
      this.key.id = [parentId, this.key.id].join('/')
    }
  }

  public setExamples(
    examples: Readonly<AxProgramExamples>,
    options?: Readonly<AxSetExamplesOptions>
  ) {
    if (!('programId' in examples)) {
      return
    }

    for (const child of this.children) {
      child.setExamples(examples, options)
    }
  }

  public getTraces(): AxProgramTrace[] {
    let traces: AxProgramTrace[] = []

    if (this.trace) {
      traces.push({ trace: this.trace, programId: this.key.id })
    }

    for (const child of this.children) {
      const _traces = child.getTraces()
      traces = [...traces, ..._traces]
    }
    return traces
  }

  public getUsage(): AxProgramUsage[] {
    let usage: AxProgramUsage[] = [...(this.usage ?? [])]

    for (const child of this.children) {
      const cu = child.getUsage()
      usage = [...usage, ...cu]
    }
    return mergeProgramUsage(usage)
  }

  public resetUsage() {
    this.usage = []
    for (const child of this.children) {
      child.resetUsage()
    }
  }

  public setDemos(demos: readonly AxProgramDemos[]) {
    for (const child of this.children) {
      child.setDemos(demos)
    }
  }
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/prompt.ts
```ts
import type { AxAIGoogleGeminiContentPart } from '../ai/google-gemini/types.js'
import type { AxChatRequest } from '../ai/types.js'

import { formatDateWithTimezone } from './datetime.js'
import type { AxInputFunctionType } from './functions.js'
import { type AxField, type AxIField, type AxSignature } from './sig.js'
import type {
  AxFileData,
  AxFieldValue,
  AxGenIn,
  AxGenOut,
  AxInlineData,
  AxMessage,
} from './types.js'
import { validateValue } from './util.js'

type Writeable<T> = { -readonly [P in keyof T]: T[P] }

// Define options type for AxPromptTemplate constructor
export interface AxPromptTemplateOptions {
  functions?: Readonly<AxInputFunctionType>
  thoughtFieldName?: string
}
type AxChatRequestChatPrompt = Writeable<AxChatRequest['chatPrompt'][0]>

type ChatRequestUserMessage = AxAIGoogleGeminiContentPart[]

const functionCallInstructions = `
## Function Call Instructions
- Complete the task, using the functions defined earlier in this prompt. 
- Call functions step-by-step, using the output of one function as input to the next.
- Use the function results to generate the output fields.`

export type AxFieldTemplateFn = (
  field: Readonly<AxField>,
  value: Readonly<AxFieldValue>
) => ChatRequestUserMessage

function xmlEscape(str: string): string {
  if (typeof str !== 'string') {
    return ''
  }
  return str.replace(/[<>&"']/g, (c) => {
    switch (c) {
      case '<':
        return '&lt;'
      case '>':
        return '&gt;'
      case '&':
        return '&amp;'
      case '"':
        return '&quot;'
      case "'":
        return '&apos;'
      default:
        return c
    }
  })
}

function fieldToXMLDef(field: AxField<any>): string {
  const attrs = [
    `type="${field.type}"`,
    field.isArray ? 'isArray="true"' : '',
    field.fieldDescription
      ? `description="${xmlEscape(field.fieldDescription)}"`
      : '',
  ]
    .filter(Boolean)
    .join(' ')

  if (field.type === 'json' && 'schema' in field && field.schema) {
    const children = field.schema.map(fieldToXMLDef).join('\n    ')
    return `<${field.name} ${attrs}>\n    ${children}\n</${field.name}>`
  }
  if (field.type === 'enum' && 'enumValueSet' in field && field.enumValueSet) {
    const values =
      field.enumValueSet.type === 'literal'
        ? field.enumValueSet.values.join(',')
        : field.enumValueSet.values.join(',')
    return `<${field.name} ${attrs} values="${xmlEscape(values)}" />`
  }
  return `<${field.name} ${attrs} />`
}

export class AxPromptTemplate {
  private sig: Readonly<AxSignature>
  private fieldTemplates?: Record<string, AxFieldTemplateFn>
  private readonly thoughtFieldName: string
  private readonly functions?: Readonly<AxInputFunctionType>

  constructor(
    sig: Readonly<AxSignature>,
    options?: Readonly<AxPromptTemplateOptions>,
    fieldTemplates?: Record<string, AxFieldTemplateFn>
  ) {
    this.sig = sig
    this.fieldTemplates = fieldTemplates
    this.thoughtFieldName = options?.thoughtFieldName ?? 'thought'
    this.functions = options?.functions
  }

  public render = <T extends AxGenIn>(
    values: T | ReadonlyArray<AxMessage>,
    {
      examples,
      demos,
      scope,
    }: Readonly<{
      skipSystemPrompt?: boolean
      examples?: Record<string, AxFieldValue>[]
      demos?: Record<string, AxFieldValue>[]
      scope?: Readonly<
        Map<string, { field: AxField<any>; value: AxFieldValue }>
      >
    }>
  ): AxChatRequest['chatPrompt'] => {
    // System Prompt Construction
    const systemTask = []
    const inArgs = renderDescFields(this.sig.getInputFields())
    const outArgs = renderDescFields(this.sig.getOutputFields())
    systemTask.push(
      `You will be provided with the following fields: ${inArgs}. Your task is to generate new fields: ${outArgs}.`
    )

    if (this.sig.getInputFields().length > 0 || (scope && scope.size > 0)) {
      systemTask.push(
        `You can reference inputs and scope variables using the format <xpath>//path/to/variable</xpath>.`
      )
    }

    if (this.sig.getInputFields().length > 0) {
      const inputDefs = this.sig.getInputFields().map(fieldToXMLDef).join('\n')
      systemTask.push(
        `<input-definitions>\n${inputDefs}\n</input-definitions>`
      )
    }

    const desc = this.sig.getDescription()
    if (desc) {
      const text = formatDescription(desc)
      systemTask.push(text)
    }

    if (this.sig.getOutputFields().length > 0) {
      const outputDefs = this.sig
        .getOutputFields()
        .map(fieldToXMLDef)
        .join('\n')
      systemTask.push(
        `<output-definitions>\n${outputDefs}\n</output-definitions>`
      )
    }

    // biome-ignore lint/complexity/useFlatMap: you cannot use flatMap here
    const funcs = this.functions
      ?.map((f) => ('toFunction' in f ? f.toFunction() : f))
      ?.flat()

    if (funcs && funcs.length > 0) {
      const funcList = funcs
        .map((fn) => `- \`${fn.name}\`: ${formatDescription(fn.description)}`)
        .join('\n')
      systemTask.push(`## Available Functions\n${funcList}`)
      systemTask.push(functionCallInstructions.trim())
    }

    if (scope && scope.size > 0) {
      systemTask.push(
        'The first user message part contains scope definitions and values.'
      )
    }

    const systemPrompt: AxChatRequestChatPrompt = {
      role: 'system' as const,
      content: [{ type: 'text', text: systemTask.join('\n\n') }],
    }

    // User/Assistant History Construction
    let history: AxChatRequestChatPrompt[] = []

    if (Array.isArray(values)) {
      // Handle AxMessage array history
      // This part needs to be implemented to render history correctly
    } else {
      const userParts: ChatRequestUserMessage = []

      // Demos & Examples
      const renderedDemos = demos ? this.renderDemos(demos) : []
      const renderedExamples = examples ? this.renderExamples(examples) : []

      userParts.push(...renderedDemos, ...renderedExamples)

      // Scope
      if (scope && scope.size > 0) {
        const scopeDefs = []
        for (const { field } of scope.values()) {
          scopeDefs.push(fieldToXMLDef(field))
        }
        userParts.push({
          type: 'text',
          text: `<scope-definitions>\n${scopeDefs.join('\n')}\n</scope-definitions>`,
        })

        for (const { field, value } of scope.values()) {
          userParts.push(...this.valueToParts(field.name, value, field))
        }
      }

      // Input Values
      userParts.push(...this.renderInputValues(values))

      history.push({ role: 'user', content: userParts })
    }

    return [systemPrompt, ...history]
  }

  private valueToParts = (
    name: string,
    value: AxFieldValue,
    field: Readonly<AxField>
  ): ChatRequestUserMessage => {
    const parts: ChatRequestUserMessage = []
    const startTag = { type: 'text' as const, text: `<${name}>` }
    const endTag = { type: 'text' as const, text: `</${name}>` }

    if (
      value &&
      typeof value === 'object' &&
      ('data' in value || 'fileUri' in value)
    ) {
      const media = value as AxInlineData | AxFileData
      const mediaPart =
        'data' in media
          ? { inlineData: { mimeType: media.mimeType, data: media.data } }
          : { fileData: { mimeType: media.mimeType, fileUri: media.fileUri } }
      return [startTag, mediaPart, endTag]
    } else if (Array.isArray(value)) {
      parts.push(startTag)
      for (const item of value) {
        // This is a simplification. A robust implementation would handle nested multimodal content.
        const textValue =
          typeof item === 'object' ? JSON.stringify(item, null, 2) : String(item)
        parts.push({ type: 'text', text: textValue })
      }
      parts.push(endTag)
      return parts
    } else {
      const textValue =
        value === null || value === undefined
          ? ''
          : typeof value === 'object'
            ? JSON.stringify(value, null, 2)
            : String(value)
      return [{ type: 'text', text: `<${name}>${xmlEscape(textValue)}</${name}>` }]
    }
  }

  private renderDemos = (data: Readonly<Record<string, AxFieldValue>[]>) =>
    this.renderExamples(data, true)

  private renderExamples = (
    data: Readonly<Record<string, AxFieldValue>[]>,
    isDemo: boolean = false
  ) => {
    const chatHistory: ChatRequestUserMessage = []
    const context = { isExample: true }

    for (const item of data) {
      // Render user part
      const userParts: ChatRequestUserMessage = this.sig
        .getInputFields()
        .flatMap((field) =>
          this.renderInField(field, item, { ...context, isInputField: true })
        )

      // Render assistant part
      const assistantParts: ChatRequestUserMessage = this.sig
        .getOutputFields()
        .flatMap((field) =>
          this.renderInField(field, item, { ...context, isInputField: false })
        )
      // This is a simplification; demos should probably be rendered as full user/assistant turns
      chatHistory.push(...userParts, ...assistantParts)
    }
    return chatHistory
  }

  private renderInputValues = <T extends AxGenIn>(
    values: T
  ): ChatRequestUserMessage => {
    return this.sig
      .getInputFields()
      .flatMap((field) => this.renderInField(field, values, undefined))
  }

  private renderInField = (
    field: Readonly<AxField>,
    values: Readonly<Record<string, AxFieldValue>>,
    context?: {
      isExample?: boolean
      isInputField?: boolean
    }
  ): ChatRequestUserMessage => {
    const value = values[field.name]

    if (isEmptyValue(field, value, context)) {
      return []
    }

    if (field.type) {
      validateValue(field, value!)
    }

    const processedValue = processValue(field, value!)
    return this.valueToParts(field.name, processedValue, field)
  }
}

const renderDescFields = (list: readonly AxField[]) =>
  list.map((v) => `\`${v.title}\``).join(', ')

const processValue = (
  field: Readonly<AxField>,
  value: Readonly<AxFieldValue>
): AxFieldValue => {
  if (field.type === 'date' && value instanceof Date) {
    const v = value.toISOString()
    return v.slice(0, v.indexOf('T'))
  }
  if (field.type === 'datetime' && value instanceof Date) {
    return formatDateWithTimezone(value)
  }
  if (
    (field.type === 'image' || field.type === 'audio' || field.type === 'video') &&
    typeof value === 'object'
  ) {
    return value
  }
  if (typeof value === 'string') {
    return value
  }
  return JSON.stringify(value, null, 2)
}

const isEmptyValue = (
  field: Readonly<AxField>,
  value?: Readonly<AxFieldValue>,
  context?: {
    isExample?: boolean
    isInputField?: boolean
  }
) => {
  if (typeof value === 'boolean') {
    return false
  }

  if (
    value === null ||
    value === undefined ||
    ((Array.isArray(value) || typeof value === 'string') && value.length === 0)
  ) {
    if (context?.isExample) {
      return true
    }

    if (field.isOptional || field.isInternal) {
      return true
    }

    const fieldType = context?.isInputField !== false ? 'input' : 'output'
    throw new Error(`Value for ${fieldType} field '${field.name}' is required.`)
  }
  return false
}

function formatDescription(str?: string) {
  if (!str) return ''
  const value = str.trim()
  return value.length > 0
    ? `${value.charAt(0).toUpperCase()}${value.slice(1)}${value.endsWith('.') ? '' : '.'}`
    : ''
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/sig.ts
```ts
import { createHash } from 'crypto'

import type { AxFunctionJSONSchema } from '../ai/types.js'

export type PRIMITIVES =
  | 'string'
  | 'number'
  | 'boolean'
  | 'json'
  | 'image'
  | 'audio'
  | 'video'
  | 'date'
  | 'datetime'
  | 'enum'
  | 'code'

export type ENUM_SET =
  | {
      type: 'literal'
      values: string[]
    }
  | {
      type: 'algebraic'
      values: PRIMITIVES[]
    }

interface AxFieldBase<T extends PRIMITIVES> {
  type: T
  name: string
  fieldDescription?: string
  isArray?: boolean
  isOptional?: boolean
  isInternal?: boolean
}

export type AxField<T extends PRIMITIVES = PRIMITIVES> = AxFieldBase<T> &
  (T extends 'string' ? { canReferenceScope?: boolean } : object) &
  (T extends 'enum' ? { enumValueSet: ENUM_SET } : object) &
  (T extends 'json' ? { schema?: AxField<any>[] } : object)

export type AxIField = AxField<any> & { title: string }

export class AxSignature {
  private description?: string
  private inputFields: AxIField[]
  private outputFields: AxIField[]

  private sigHash: string
  private sigString: string

  constructor(signature?: Readonly<AxSignature>) {
    if (!signature) {
      this.inputFields = []
      this.outputFields = []
      this.sigHash = ''
      this.sigString = ''
      return
    }

    if (signature instanceof AxSignature) {
      this.description = signature.getDescription()
      this.inputFields = structuredClone(
        signature.getInputFields()
      ) as AxIField[]
      this.outputFields = structuredClone(
        signature.getOutputFields()
      ) as AxIField[]
      this.sigHash = signature.hash()
      this.sigString = signature.toString()
    } else {
      throw new Error('invalid signature argument: ' + signature)
    }
  }

  private parseField = (field: Readonly<AxField<any>>): AxIField => {
    const title = this.toTitle(field.name)

    if (field.type && (field.type.length === 0 || !field.type)) {
      throw new Error('Field type name is required: ' + field.name)
    }

    return { ...field, title, description: field.fieldDescription }
  }

  public setDescription = (desc: string) => {
    this.description = desc
    this.updateHash()
  }

  public addInputField = (field: Readonly<AxField<any>>) => {
    this.inputFields.push(this.parseField(field))
    this.updateHash()
  }

  public addOutputField = (field: Readonly<AxField<any>>) => {
    this.outputFields.push(this.parseField(field))
    this.updateHash()
  }

  public setInputFields = (fields: readonly AxField<any>[]) => {
    this.inputFields = fields.map((v) => this.parseField(v))
    this.updateHash()
  }

  public setOutputFields = (fields: readonly AxField<any>[]) => {
    this.outputFields = fields.map((v) => this.parseField(v))
    this.updateHash()
  }

  public getInputFields = (): Readonly<AxIField[]> => this.inputFields
  public getOutputFields = (): Readonly<AxIField[]> => this.outputFields
  public getDescription = () => this.description

  private toTitle = (name: string) => {
    let result = name.replace(/_/g, ' ')
    result = result.replace(/([A-Z]|[0-9]+)/g, ' $1').trim()
    return result.charAt(0).toUpperCase() + result.slice(1)
  }

  public toJSONSchema = (): AxFunctionJSONSchema => {
    const properties: Record<string, unknown> = {}
    const required: Array<string> = []

    for (const f of this.inputFields) {
      const type = f.type ? f.type : 'string'
      if (f.isArray) {
        properties[f.name] = {
          description: f.fieldDescription,
          type: 'array' as const,
          items:
            type === 'json' && 'schema' in f && f.schema
              ? this.nestedToJSONSchema(f.schema)
              : {
                  type: type,
                  description: f.fieldDescription,
                },
        }
      } else if (type === 'json' && 'schema' in f && f.schema) {
        properties[f.name] = this.nestedToJSONSchema(f.schema)
        properties[f.name].description = f.fieldDescription
      } else {
        properties[f.name] = {
          description: f.fieldDescription,
          type: type,
        }
      }

      if (!f.isOptional) {
        required.push(f.name)
      }
    }

    const schema = {
      type: 'object',
      properties: properties,
      required: required,
    }

    return schema as AxFunctionJSONSchema
  }

  private nestedToJSONSchema(fields: readonly AxField<any>[]) {
    const properties: Record<string, unknown> = {}
    const required: Array<string> = []

    for (const f of fields) {
      const type = f.type ? f.type : 'string'
      if (f.isArray) {
        properties[f.name] = {
          description: f.fieldDescription,
          type: 'array' as const,
          items:
            type === 'json' && 'schema' in f && f.schema
              ? this.nestedToJSONSchema(f.schema)
              : { type },
        }
      } else if (type === 'json' && 'schema' in f && f.schema) {
        properties[f.name] = this.nestedToJSONSchema(f.schema)
      } else {
        properties[f.name] = {
          description: f.fieldDescription,
          type,
        }
      }

      if (!f.isOptional) {
        required.push(f.name)
      }
    }

    return { type: 'object', properties, required }
  }

  private updateHash = (): [string, string] => {
    this.getInputFields().forEach((field) => {
      validateField(field)
    })
    this.getOutputFields().forEach((field) => {
      validateField(field)
      if (field.type === 'image') {
        throw new Error('Image type is not supported in output fields.')
      }
    })

    this.sigHash = createHash('sha256')
      .update(this.description ?? '')
      .update(JSON.stringify(this.inputFields))
      .update(JSON.stringify(this.outputFields))
      .digest('hex')

    this.sigString = renderSignature(
      this.description,
      this.inputFields,
      this.outputFields
    )

    return [this.sigHash, this.sigString]
  }

  public hash = () => this.sigHash

  public toString = () => this.sigString

  public toJSON = () => {
    return {
      id: this.hash(),
      description: this.description,
      inputFields: this.inputFields,
      outputFields: this.outputFields,
    }
  }
}

function renderField(field: Readonly<AxField>): string {
  let result = field.name
  if (field.isOptional) {
    result += '?'
  }
  if (field.type) {
    result += ':' + field.type
    if (field.isArray) {
      result += '[]'
    }
  }
  // Check if description exists and append it.
  if (field.fieldDescription) {
    result += ` "${field.fieldDescription}"`
  }
  return result
}

function renderSignature(
  description: string | undefined,
  inputFields: readonly AxField[],
  outputFields: readonly AxField[]
): string {
  // Prepare the description part of the signature.
  const descriptionPart = description ? `"${description}"` : ''

  // Render each input field into a comma-separated list.
  const inputFieldsRendered = inputFields.map(renderField).join(', ')

  // Render each output field into a comma-separated list.
  const outputFieldsRendered = outputFields.map(renderField).join(', ')

  // Combine all parts into the final signature.
  return `${descriptionPart} ${inputFieldsRendered} -> ${outputFieldsRendered}`
}

function isValidCase(inputString: string): boolean {
  const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/
  const snakeCaseRegex = /^[a-z]+(_[a-z0-9]+)*$/

  return camelCaseRegex.test(inputString) || snakeCaseRegex.test(inputString)
}

function validateField(field: Readonly<AxField>): void {
  if (!field.name || field.name.length === 0) {
    throw new Error('Field name cannot be blank')
  }

  if (!isValidCase(field.name)) {
    throw new Error(
      `Invalid field name '${field.name}', it must be camel case or snake case: `
    )
  }

  if (
    [
      'text',
      'object',
      'image',
      'string',
      'number',
      'boolean',
      'json',
      'array',
      'datetime',
      'date',
      'time',
      'type',
      'class',
      'video',
      'audio',
      'enum',
      'code',
    ].includes(field.name)
  ) {
    throw new Error(
      `Invalid field name '${field.name}', please make it more descriptive (eg. companyDescription)`
    )
  }
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/types.ts
```ts
// Supported Image MIME Types
export type AxImageMimeType =
  | 'image/png'
  | 'image/jpeg'
  | 'image/webp'
  | 'image/heic'
  | 'image/heif'

// Supported Audio MIME Types
export type AxAudioMimeType =
  | 'audio/wav'
  | 'audio/mp3'
  | 'audio/aiff'
  | 'audio/aac'
  | 'audio/ogg'
  | 'audio/flac'

// Supported Video MIME Types
export type AxVideoMimeType =
  | 'video/mp4'
  | 'video/mpeg'
  | 'video/mov'
  | 'video/avi'
  | 'video/x-flv'
  | 'video/mpg'
  | 'video/webm'
  | 'video/wmv'
  | 'video/3gpp'

// Supported PDF MIME Type
export type AxPdfMimeType = 'application/pdf'

export type AxMediaMimeType =
  | AxImageMimeType
  | AxAudioMimeType
  | AxVideoMimeType
  | AxPdfMimeType

export type AxFileData = {
  mimeType: AxMediaMimeType
  fileUri: string
}

// base64-encoded
export type AxInlineData = {
  mimeType: AxMediaMimeType
  data: string
}

export type AxFieldValue =
  | string
  | number
  | boolean
  | object
  | null
  | undefined
  | AxFileData
  | AxInlineData
  | AxFieldValue[]

export type AxGenIn = { [key: string]: AxFieldValue }

export type AxGenOut = Record<string, AxFieldValue>

export type AxMessage =
  | { role: 'user'; values: AxGenIn }
  | { role: 'assistant'; values: AxGenOut }
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/util.ts
```ts
import { ColorLog } from '../util/log.js'

import type { AxExample, AxOptimizationStats } from './optimize.js'
import type { AxProgramUsage } from './program.js'
import type { AxField } from './sig.js'
import type { AxFieldValue, AxGenOut, AxInlineData } from './types.js'

const colorLog = new ColorLog()

export const updateProgressBar = (
  current: number,
  total: number,
  success: number,
  elapsedTime: number, // in seconds
  msg: string,
  progressBarWidth = 20 // Default width of the progress bar
): void => {
  const percentage = ((current / total) * 100).toFixed(1)
  const filledBarLength = Math.round((progressBarWidth * current) / total)
  const emptyBarLength = progressBarWidth - filledBarLength
  const filledBar = colorLog.blueBright('█'.repeat(filledBarLength))
  const emptyBar = ' '.repeat(emptyBarLength)
  const itemsPerSecond =
    elapsedTime > 0 ? (current / elapsedTime).toFixed(2) : '0.00'

  process.stdout.write(
    `\r${msg}: ${current} / ${total} (${colorLog.yellow(percentage)}%): 100%|${filledBar}${emptyBar}| Success: ${success}/${total} [${colorLog.red(elapsedTime.toFixed(2))}, ${itemsPerSecond}it/s]`
  )
}

export const validateValue = (
  field: Readonly<AxField>,
  value: Readonly<AxFieldValue>
): void => {
  const ft = field.type ?? 'string'

  const validateSingleValue = (
    expectedType: string,
    val: Readonly<AxFieldValue>
  ): boolean => {
    switch (expectedType) {
      case 'enum':
      case 'code':
      case 'string':
        return typeof val === 'string'
      case 'number':
        return typeof val === 'number'
      case 'boolean':
        return typeof val === 'boolean'
      case 'date':
      case 'datetime':
        return val instanceof Date || typeof val === 'string'
      case 'json':
        return typeof val === 'object' || typeof val === 'string'
      default:
        return false // Unknown or unsupported type
    }
  }

  const validMedia = (val: Readonly<AxFieldValue>): boolean => {
    if (
      !val ||
      typeof val !== 'object' ||
      !('mimeType' in val) ||
      (!('data' in val) && !('fileUri' in val))
    ) {
      return false
    }
    return true
  }

  if (
    field.type === 'image' ||
    field.type === 'video' ||
    field.type === 'audio'
  ) {
    let msg: string | undefined
    const expected = `object ({ mimeType: string; data: string | fileUri: string })`
    if (Array.isArray(value)) {
      if (!field.isArray) {
        msg = `Expected a single media object, but got an array.`
      }
      for (const item of value) {
        if (!validMedia(item)) {
          msg = `Expected an array of ${expected}`
          break
        }
      }
    } else if (!validMedia(value)) {
      msg = `Expected ${expected}`
    }

    if (msg) {
      throw new Error(
        `Validation failed: For field '${field.name}', ${msg} but got '${JSON.stringify(value)}'`
      )
    }
    return
  }

  let isValid = true

  if (field.isArray) {
    if (!Array.isArray(value)) {
      isValid = false
    } else {
      for (const item of value) {
        if (!validateSingleValue(ft, item)) {
          isValid = false
          break
        }
      }
    }
  } else {
    isValid = validateSingleValue(ft, value)
  }

  if (!isValid) {
    const gotType = Array.isArray(value) ? 'array' : typeof value
    throw new Error(
      `Validation failed: Expected '${field.name}' to be a ${field.isArray ? 'an array of ' : ''}${ft} instead got '${gotType}' (${JSON.stringify(value)})`
    )
  }
}

export function mergeProgramUsage(
  usages: readonly AxProgramUsage[]
): AxProgramUsage[] {
  const usageMap: { [key: string]: AxProgramUsage } = {}

  for (const usage of usages) {
    const key = `${usage.ai}:${usage.model}`

    if (!usageMap[key]) {
      usageMap[key] = { ...usage }
      continue
    }

    const currentUsage = usageMap[key]
    if (currentUsage) {
      const tokens = currentUsage.tokens ?? {
        promptTokens: 0,
        completionTokens: 0,
        totalTokens: 0,
      }
      tokens.promptTokens += usage?.tokens?.promptTokens ?? 0
      tokens.completionTokens += usage?.tokens?.completionTokens ?? 0
      tokens.totalTokens += usage?.tokens?.totalTokens ?? 0
      currentUsage.tokens = tokens
    }
  }

  return Object.values(usageMap)
}

/**
 * Parses a markdown list from a string. This is a very forgiving parser that
 * will try to handle anything that looks vaguely like a markdown list.
 */
export const parseMarkdownList = (input: string): string[] => {
  // Handle empty input
  if (!input.trim()) {
    return []
  }

  const listBullets = new Set(['-', '*', '+'])
  const numberedListRegex = /^\d+[\s]*[.)\]]\s*/

  const lines = input.split('\n')
  const list = []

  for (const line of lines) {
    const trimmedLine = line.trim()
    // Skip empty lines
    if (!trimmedLine) {
      continue
    }

    // Check for bullet points
    if (trimmedLine[0] && listBullets.has(trimmedLine[0])) {
      list.push(trimmedLine.slice(1).trim())
    }
    // Check for numbered lists (e.g., "1.", "2.", etc.)
    else if (numberedListRegex.test(trimmedLine)) {
      list.push(trimmedLine.replace(numberedListRegex, '').trim())
    }
    // If it's not a list item and we haven't collected any items yet, do nothing
    else if (list.length === 0) {
      // Skip non-list lines at the beginning
    }
    // If we've already started collecting list items, then this non-list line
    //is an error
    else {
      throw new Error('Could not parse markdown list: mixed content detected')
    }
  }

  // If we didn't find any list items, throw error
  if (list.length === 0) {
    throw new Error('Could not parse markdown list: no valid list items found')
  }

  return list
}

export function mergeDeltas<OUT extends AxGenOut>(
  base: Partial<AxGenOut>,
  delta: Partial<AxGenOut>
) {
  for (const key of Object.keys(delta)) {
    const baseValue = base[key]
    const deltaValue = delta[key]

    if (baseValue === undefined && Array.isArray(deltaValue)) {
      base[key] = [...deltaValue]
    } else if (Array.isArray(baseValue) && Array.isArray(deltaValue)) {
      // Concatenate arrays
      base[key] = [...(baseValue ?? []), ...deltaValue]
    } else if (
      (baseValue === undefined || typeof baseValue === 'string') &&
      typeof deltaValue === 'string'
    ) {
      // Concatenate strings
      base[key] = (baseValue ?? '') + deltaValue
    } else {
      // For all other types, overwrite with the new value
      base[key] = deltaValue
    }
  }
  return base as OUT
}

export class LRUCache<K, V> {
  private cache = new Map<K, V>()
  private readonly maxSize: number

  constructor(maxSize: number) {
    this.maxSize = maxSize
  }

  get(key: K): V | undefined {
    const value = this.cache.get(key)
    if (value) {
      // Refresh position by deleting and re-adding
      this.cache.delete(key)
      this.cache.set(key, value)
    }
    return value
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key)
    } else if (this.cache.size >= this.maxSize) {
      // Remove oldest entry (first item in map)
      const firstKey = this.cache.keys().next().value
      if (firstKey) {
        this.cache.delete(firstKey)
      }
    }
    this.cache.set(key, value)
  }
}

const globalPrefixCache = new LRUCache<string, string[]>(500)

/**
 * Checks if a streaming string matches a prefix, either fully or partially from the end.
 * For streaming content, partial matches are checked from shortest to longest since
 * the content grows at the end and we want to detect partial prefixes as they form.
 * @param content The string to check (potentially streaming)
 * @param prefix The prefix to look for
 * @param startIndex Optional starting index for the search
 * @returns
 *   - index >= 0: Position of full match
 *   - -1: No match found
 *   - -2: Partial match from the end
 *   - -3: String is only whitespace
 */
export function matchesContent(
  content: string,
  prefix: string,
  startIndex = 0,
  prefixCache: LRUCache<string, string[]> = globalPrefixCache
): number {
  // Check if string starts with a markdown block with optional language
  if (/^```[a-zA-Z]*\s*$/.test(content)) {
    return -4
  }

  // Check if string is only whitespace
  if (/^[\s`]*$/.test(content)) {
    return -3
  }

  // First check if the complete prefix exists anywhere after startIndex
  const exactMatchIndex = content.indexOf(prefix, startIndex)

  if (exactMatchIndex !== -1) {
    return exactMatchIndex
  }

  // Get or create cached prefixes
  const prefixes =
    prefixCache.get(prefix) ??
    Array.from({ length: prefix.length }, (_, i) => prefix.slice(0, i + 1))

  // Set in cache if it wasn't there
  if (!prefixCache.get(prefix)) {
    prefixCache.set(prefix, prefixes)
  }

  // Get the content slice we'll check for partial matches
  const contentEnd = content.slice(
    Math.max(startIndex, content.length - prefix.length)
  )

  // Check for partial matches at the end, starting from shortest to longest
  // Skip the full prefix as it was already checked
  for (let i = 0; i < prefixes.length - 1; i++) {
    const partialPrefix = prefixes[i]
    if (partialPrefix === '\n' || partialPrefix === ':') {
      continue
    }
    if (partialPrefix && contentEnd.endsWith(partialPrefix)) {
      return -2
    }
  }

  return -1
}

export const formatTime = (ms: number): string => {
  const seconds = Math.floor(ms / 1000)
  if (seconds < 60) return `${seconds}s`

  const minutes = Math.floor(seconds / 60)
  const remainingSeconds = seconds % 60
  if (minutes < 60) return `${minutes}m ${remainingSeconds}s`

  const hours = Math.floor(minutes / 60)
  const remainingMinutes = minutes % 60
  return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`
}

export const calculateETA = (
  current: number,
  total: number,
  elapsedMs: number
): string => {
  if (current === 0) return 'calculating...'

  const msPerItem = elapsedMs / current
  const remainingItems = total - current
  const etaMs = msPerItem * remainingItems

  return formatTime(etaMs)
}

interface ProgressConfigInfo {
  maxRounds: number
  batchSize: number
  earlyStoppingPatience: number
  costMonitoring: boolean
  verboseMode: boolean
  debugMode: boolean
}

export const updateDetailedProgress = <T extends AxGenOut = AxGenOut>(
  roundIndex: number,
  current: number,
  total: number,
  elapsedTime: number,
  example: Readonly<AxExample>,
  stats: Readonly<AxOptimizationStats>,
  configInfo: Readonly<ProgressConfigInfo>,
  result?: T,
  error?: Error
): void => {
  // Clear line and create a formatted output
  process.stdout.write('\r\x1b[K')

  const percentage = ((current / total) * 100).toFixed(1)
  const formattedTime = formatTime(elapsedTime)
  const itemsPerSecond =
    elapsedTime > 0 ? ((current / elapsedTime) * 1000).toFixed(2) : '0.00'
  const eta = calculateETA(current, total, elapsedTime)

  // Basic progress info (always shown)
  let output = `Round ${roundIndex + 1}/${configInfo.maxRounds}: ${current}/${total} (${percentage}%) [${formattedTime}, ${itemsPerSecond} it/s, ETA: ${eta}]`

  // Add success stats
  const successRate =
    stats.totalCalls > 0 ? (stats.successfulDemos / stats.totalCalls) * 100 : 0
  output += ` | Success: ${stats.successfulDemos}/${stats.totalCalls} (${successRate.toFixed(1)}%)`

  // Additional info for verbose mode
  if (configInfo.verboseMode || configInfo.debugMode) {
    if (configInfo.costMonitoring) {
      output += `\n  Tokens: ~${stats.estimatedTokenUsage.toLocaleString()} total`
    }

    output += `\n  Batch: ${Math.floor(current / configInfo.batchSize) + 1}/${Math.ceil(total / configInfo.batchSize)}`

    if (configInfo.earlyStoppingPatience > 0 && stats.earlyStopping) {
      output += `\n  Best round: ${stats.earlyStopping.bestScoreRound + 1}, Patience: ${configInfo.earlyStoppingPatience}`
    }
  }

  // Debug mode gets even more info
  if (configInfo.debugMode) {
    // Truncate example keys for display
    const exampleKeys = Object.keys(example)
      .map((k) => {
        const valueStr = JSON.stringify(example[k])
        const truncated =
          valueStr.length > 30 ? `${valueStr.substring(0, 30)}...` : valueStr
        return `${k}: ${truncated}`
      })
      .join(', ')

    output += `\n  Example: {${exampleKeys}}`

    if (error) {
      output += `\n  ERROR: ${error.message}`
    } else if (result) {
      // Truncate result for display
      const resultStr = JSON.stringify(result)
      const truncatedResult =
        resultStr.length > 50 ? `${resultStr.substring(0, 50)}...` : resultStr
      output += `\n  Result: ${truncatedResult}`
    }

    // Add temperature info
    output += `\n  Temperature: ${(0.7 + 0.001 * current).toFixed(3)}`
  }

  console.log(output)
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/dsp/validate.ts
```ts
import type { AxAIService } from '../ai/types.js'
import type { AxAIMemory } from '../mem/types.js'

import { AxPromptTemplate, toFieldType } from './prompt.js'
import type { AxField, AxIField } from './sig.js'

export class ValidationError extends Error {
  private fields: AxField[]

  constructor({
    message,
    fields,
  }: Readonly<{
    message: string
    fields: AxField[]
    value?: string
  }>) {
    super(message)
    this.fields = fields
    this.name = this.constructor.name
  }

  public getFixingInstructions = () => {
    return this.fields.map((field) => ({
      name: 'outputError',
      title: 'Output Correction Required',
      description: `The section labeled '${field.name}' either was not generated by the LLM or does not match the expected format of '${toFieldType(field)}'. ${this.message} Please revise your response to ensure it conforms to the specified format.`,
    }))
  }

  override toString(): string {
    return [
      `${this.name}: ${this.message}`,
      ...this.fields.map(
        (field) =>
          `  - ${field.name}: Expected format '${toFieldType(field)}'`
      ),
    ].join('\n')
  }

  [Symbol.for('nodejs.util.inspect.custom')](
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _depth: number,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _options: Record<string, unknown>
  ) {
    return this.toString()
  }
}

export function handleValidationError(
  mem: AxAIMemory,
  errorFields: AxIField[],
  ai: Readonly<AxAIService>,
  promptTemplate: Readonly<AxPromptTemplate>,
  sessionId?: string
) {
  mem.add(
    {
      role: 'user' as const,
      content: promptTemplate.renderExtraFields(errorFields),
    },
    sessionId
  )
  mem.addTag('error')

  if (ai.getOptions().debug) {
    const errors = errorFields
      .map((field) => `- ${field.title}: ${field.description}`)
      .join('\n')

    const logger = ai.getLogger()
    logger(`❌ Error Correction:\n${errors}`, {
      tags: ['error'],
    })
  }
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/prompts/cot.ts
```ts
import { AxGen, type AxGenOptions } from '../dsp/generate.js'
import { AxSignature } from '../dsp/sig.js'
import type { AxGenIn, AxGenOut } from '../dsp/types.js'

export class AxChainOfThought<
  IN extends AxGenIn = AxGenIn,
  OUT extends AxGenOut = AxGenOut,
> extends AxGen<IN, OUT> {
  constructor(
    signature: Readonly<AxSignature>,
    options?: Readonly<AxGenOptions & { setVisibleReasoning?: boolean }>
  ) {
    const sig = new AxSignature(signature)
    const description = `Let's work this out in a step by step way in order to ensure we have the right answer.`

    const existingOutputs = sig.getOutputFields()

    sig.setOutputFields([
      {
        name: 'reason',
        type: 'string',
        fieldDescription: description,
        isInternal: options?.setVisibleReasoning !== true,
      },
      ...existingOutputs,
    ])

    super(sig, options)
  }
}
```
File: /Users/abemillan/Developer/ax-vanilla/src/ax/prompts/rag.ts
```ts
import { type AxProgramForwardOptions } from '../dsp/program.js'
import { AxStringUtil } from '../dsp/strutil.js'
import {
  type AxAIService,
  AxGen,
  type AxGenOptions,
  AxSignature,
} from '../index.js'

import { AxChainOfThought } from './cot.js'

export class AxRAG extends AxChainOfThought<
  { context: string[]; question: string },
  { answer: string }
> {
  private genQuery: AxGen<
    { context: string[]; question: string },
    { query: string }
  >
  private queryFn: (query: string) => Promise<string>
  private maxHops: number

  constructor(
    queryFn: (query: string) => Promise<string>,
    options: Readonly<AxGenOptions & { maxHops?: number }>
  ) {
    const sig = new AxSignature()
    sig.setDescription('Answer questions with short factoid answers.')
    sig.addInputField({
      name: 'context',
      type: 'string',
      isArray: true,
      fieldDescription: 'may contain relevant facts',
    })
    sig.addInputField({ name: 'question', type: 'string' })
    sig.addOutputField({ name: 'answer', type: 'string' })

    super(sig, options)

    this.maxHops = options?.maxHops ?? 3

    const qsig = new AxSignature()
    qsig.setDescription(
      'Write a simple search query that will help answer a complex question.'
    )
    qsig.addInputField({
      name: 'context',
      type: 'string',
      isArray: true,
      isOptional: true,
      fieldDescription: 'may contain relevant facts',
    })
    qsig.addInputField({ name: 'question', type: 'string' })
    qsig.addOutputField({
      name: 'query',
      type: 'string',
      fieldDescription: 'question to further our understanding',
    })

    this.genQuery = new AxGen<
      { context: string[]; question: string },
      { query: string }
    >(qsig)
    this.queryFn = queryFn
    this.register(this.genQuery)
  }

  public override async forward(
    ai: Readonly<AxAIService>,
    { question }: Readonly<{ question: string }>,
    options?: Readonly<AxProgramForwardOptions>
  ): Promise<{ answer: string }> {
    let context: string[] = []

    for (let i = 0; i < this.maxHops; i++) {
      const { query } = await this.genQuery.forward(
        ai,
        {
          context,
          question,
        },
        options
      )
      const val = await this.queryFn(query)
      context = AxStringUtil.dedup([...context, val])
    }

    return super.forward(ai, { context, question }, options)
  }
}
```